[
  {
    "objectID": "conteudos/pacotes/1 - Distribui√ß√£o de programas.html",
    "href": "conteudos/pacotes/1 - Distribui√ß√£o de programas.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Seu sistema computacional √© composto por muitos pacotes, como navegadores de internet, editores de texto, reprodutores de m√≠dia, etc. Esses pacotes s√£o gerenciados por gerenciadores de pacotes, que instalam e mant√©m o software no seu sistema. No entanto, nem todos os pacotes s√£o instalados via gerenciadores de pacotes. √â comum instalar pacotes diretamente a partir do seu c√≥digo fonte. Mas a maioria do tempo voc√™ usar√° um gerenciador de pacotes para instalar software (apt, dnf..).\nOs pacotes mais comuns s√£o do tipo Debian (.deb) e Red Hat (.rpm). Os pacotes do estilo Debian s√£o usados nas distribui√ß√µes como Debian, Ubuntu, LinuxMint, etc. J√° os pacotes do estilo Red Hat s√£o vistos nas distribui√ß√µes Red Hat Enterprise Linux, Fedora, CentOS, Rocky etc.\nO que s√£o Pacotes?\nVoc√™ pode conhec√™-los como Chrome, Photoshop, etc. Mas eles realmente s√£o apenas muitos arquivos compilados em um √∫nico arquivo. Os desenvolvedores (ou em algum caso, uma pessoa √∫nica) que escrevem esse software s√£o conhecidos como fornecedores upstream. Eles compilam seu c√≥digo e criam um manual sobre como instalar o software. Esses fornecedores upstream trabalham para desenvolver novas funcionalidades e atualizar o software existente. Quando estiverem prontos para liberar para o mundo, eles enviam o pacote para os mantenedores de pacotes, que s√£o respons√°veis por distribuir o software em forma de pacotes.\nArquivo de Exemplo\nSe voc√™ quiser explorar um pacote Debian, por exemplo, voc√™ pode baixar o arquivo chromium-browser_91.0.4472.114-1_amd64.deb e instalar o navegador Chromium.\nOutro Exemplo\nSe voc√™ quiser olhar o c√≥digo fonte do pacote RPM, voc√™ pode fazer isso baixando o arquivo wget-1.21.1-5.2.amd64.rpm e examinando as informa√ß√µes sobre a instala√ß√£o.\nLembre-se de que esses s√£o apenas exemplos, e os pacotes podem ter nomes e extens√µes diferentes, dependendo do tipo de pacote e da distribui√ß√£o utilizada.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Distribui√ß√£o De Programas"
    ]
  },
  {
    "objectID": "conteudos/pacotes/4 - Depend√™ncia de pacotes.html",
    "href": "conteudos/pacotes/4 - Depend√™ncia de pacotes.html",
    "title": "Pacotes e Depend√™ncias",
    "section": "",
    "text": "Pacotes e Depend√™ncias\nEm geral, os pacotes funcionam melhor quando s√£o acompanhados por depend√™ncias que os ajudam a trabalhar. Por exemplo, imagine um grupo de restaurantes que preparam diferentes tipos de comida, mas que obt√™m seus ingredientes de uma mesma granja. A comida dos restaurantes depende da granja. Se a granja parasasse de fornecer ingredientes abruptamente, os restaurantes estariam em situa√ß√£o grav√≠ssima.\nNas distribui√ß√µes Linux, essas depend√™ncias s√£o frequentemente outros pacotes ou bibliotecas compartilhadas. Bibliotecas compartilhadas s√£o cole√ß√µes de c√≥digo que outros programas desejam utilizar e n√£o desejam ter que rewriting para si mesmos. Pense novamente nos restaurantes, quantas horas cada um teria que trabalhar se tamb√©m tivessem que cultivar seus pr√≥prios ingredientes?¬†\nApenas lembre-se de que os pacotes t√™m depend√™ncias para funcionar, seja essas depend√™ncias outros pacotes ou bibliotecas. Se as depend√™ncias n√£o forem encontradas, o pacote ficar√° em estado quebrado e muitas vezes nem sequer ser√° poss√≠vel instalar.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Depend√™ncia De Pacotes"
    ]
  },
  {
    "objectID": "conteudos/pacotes/7 - Compilando.html",
    "href": "conteudos/pacotes/7 - Compilando.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Instalando um pacote em forma de c√≥digo-fonte\nMuitas vezes, voc√™ encontrar√° um pacote obscuro que apenas vem em forma de c√≥digo-fonte puro. Nesse caso, voc√™ precisar√° usar alguns comandos para converter esse c√≥digo-fonte em pacote compil√°vel e instal√°vel em seu sistema.\nPasso 1: Instalar ferramentas de compila√ß√£o\nPrimeiramente, voc√™ precisar√° instalar ferramentas para compilar c√≥digo-fonte. Use o comando a seguir:\n$ sudo apt install build-essential\nPasso 2: EXTRAIR conte√∫do do pacote\nExtrai o conte√∫do do pacote em forma de arquivo .tar.gz. Use o comando a seguir:\n$ tar -xzvf package.tar.gz\nLer README e INSTALL\nAntes de come√ßar a instalar o pacote, certifique-se de ler o arquivo README ou INSTALL dentro do pacote. Algumas vezes, h√° instru√ß√µes de instala√ß√£o espec√≠ficas.\nCompilar o pacote\nO m√©todo de compila√ß√£o utilizado pelo desenvolvedor pode variar. No entanto, a maioria dos pacotes √© compil√°vel usando o m√©todo de compila√ß√£o b√°sica. Nessa se√ß√£o, vamos discutir como compilar usando o m√©todo make.\nConfigure a compila√ß√£o\nDentro do conte√∫do do pacote, h√° um script de configura√ß√£o que verifica as depend√™ncias do sistema e se voc√™ estiver faltando alguma coisa, voc√™ ver√° um erro e precisar√° resolver essas depend√™ncias.\nUse o comando a seguir:\n$ ./configure\nO caractere './' permite executar um script no diret√≥rio atual.\nCompilar o pacote\nEm seguida, compilar o pacote usando o comando seguinte:\n$ make\nO comando make analisa o arquivo Makefile e constr√≥i o software de acordo com as regras definidas nesse arquivo.\nInstalar o pacote\nPara instalar o pacote, use o comando a seguir:\n$ sudo make install\nEssa comandos copia os arquivos corretos para as localiza√ß√µes corretas no seu computador.\nDessinstalar o pacote\nSe voc√™ quiser remover o pacote, use o comando a seguir:\n$ sudo make uninstall\nNo entanto, √© importante ter cuidado ao usar o comando make install, pois voc√™ pode n√£o estar ciente do que est√° acontecendo em segundo plano. Em vez disso, use o comando checkinstall, que constr√≥i um arquivo .deb para voc√™ e o instala facilmente.\nUse o comando a seguir:\n$ sudo checkinstall\nEsse comando executar√° o comando make install e construir√° um arquivo .deb e o instalar√°. Isso torna mais f√°cil remover o pacote mais tarde.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Compilando"
    ]
  },
  {
    "objectID": "conteudos/pacotes/6 - Yum e Apt.html",
    "href": "conteudos/pacotes/6 - Yum e Apt.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Esses sistemas acompanham todos os recursos necess√°rios para tornar a instala√ß√£o, remo√ß√£o e altera√ß√£o de pacotes mais f√°ceis, incluindo a instala√ß√£o de depend√™ncias de pacote. Dois dos gerenciadores de pacotes mais populares s√£o o dnf e o apt. O dnf √© exclusivo da fam√≠lia Red Hat, enquanto o apt √© exclusivo da fam√≠lia Debian.\n¬†\nInstalar um pacote de um reposit√≥rio\n\nNo Debian: $ apt install package_name\nNo RPM: $ dnf install package_name\n\nRemover um pacote\n\nNo Debian: $ apt remove package_name\nNo RPM: $ dnf remove package_name\n\nAtualizar pacotes de um reposit√≥rio\n√â sempre uma boa pr√°tica atualizar seus reposit√≥rios de pacotes para que estejam atualizados antes de instalar e atualizar um pacote.\n\nNo Debian: apt update; apt upgrade\n\nNo RPM: dnf update\n\n\nObter informa√ß√µes sobre um pacote instalado\n\nNo Debian: apt show package_name\nNo RPM: dnf info package_name\n\nExemplo: Instalar o pacote htop no Debian:\n$ sudo apt install htop\nExemplo: Remover o pacote git no RPM:\n$ sudo dnf remove git\nNota: √© importante verificar se o reposit√≥rio √© confi√°vel antes de realizar as atualiza√ß√µes.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Yum E Apt"
    ]
  },
  {
    "objectID": "conteudos/pacotes/6 - Yum e Apt.html#gerenciamento-de-pacotes-yum-e-apt",
    "href": "conteudos/pacotes/6 - Yum e Apt.html#gerenciamento-de-pacotes-yum-e-apt",
    "title": "linuxteclab",
    "section": "",
    "text": "Esses sistemas acompanham todos os recursos necess√°rios para tornar a instala√ß√£o, remo√ß√£o e altera√ß√£o de pacotes mais f√°ceis, incluindo a instala√ß√£o de depend√™ncias de pacote. Dois dos gerenciadores de pacotes mais populares s√£o o dnf e o apt. O dnf √© exclusivo da fam√≠lia Red Hat, enquanto o apt √© exclusivo da fam√≠lia Debian.\n¬†\nInstalar um pacote de um reposit√≥rio\n\nNo Debian: $ apt install package_name\nNo RPM: $ dnf install package_name\n\nRemover um pacote\n\nNo Debian: $ apt remove package_name\nNo RPM: $ dnf remove package_name\n\nAtualizar pacotes de um reposit√≥rio\n√â sempre uma boa pr√°tica atualizar seus reposit√≥rios de pacotes para que estejam atualizados antes de instalar e atualizar um pacote.\n\nNo Debian: apt update; apt upgrade\n\nNo RPM: dnf update\n\n\nObter informa√ß√µes sobre um pacote instalado\n\nNo Debian: apt show package_name\nNo RPM: dnf info package_name\n\nExemplo: Instalar o pacote htop no Debian:\n$ sudo apt install htop\nExemplo: Remover o pacote git no RPM:\n$ sudo dnf remove git\nNota: √© importante verificar se o reposit√≥rio √© confi√°vel antes de realizar as atualiza√ß√µes.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Yum E Apt"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/4-touch.html",
    "href": "conteudos/linha-de-comando/4-touch.html",
    "title": "touch",
    "section": "",
    "text": "touch\nVamos aprender como fazer alguns arquivos. Uma maneira muito simples √© usar o comando touch, touch permite criar novos arquivos vazios.\n$ touch meuarquivo\nE bum, novo arquivo!\nO touch tamb√©m √© usado para alterar carimbos de data/hora em arquivos e diret√≥rios existentes, na verdade essa seria a principal fun√ß√£o, pois para criar arquivos temos meios mais eficientes. Experimente, fa√ßa um ls -l em um arquivo e anote o carimbo de data/hora, depois execute touch nesse arquivo e ele atualizar√° o carimbo(informa√ß√£o) de data/hora.\nExistem muitas outras maneiras de criar arquivos que envolvem outras coisas como redirecionamento e editores de texto, mas falaremos disso no curso Manipula√ß√£o de Texto.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Touch"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/1-pwd.html",
    "href": "conteudos/linha-de-comando/1-pwd.html",
    "title": "pwd",
    "section": "",
    "text": "pwd\nTudo no Linux √© um arquivo. √Ä medida que voc√™ se aprofunda no Linux, voc√™ entender√° isso, mas por enquanto mantenha isso em mente. Cada arquivo √© organizado em uma √°rvore de diret√≥rios hier√°rquica. O primeiro diret√≥rio no sistema de arquivos √© apropriadamente denominado diret√≥rio raiz ou root, seria semelhante a unidade C: no Windows. O diret√≥rio raiz possui muitas pastas e arquivos nos quais voc√™ pode armazenar mais pastas e arquivos, etc. Aqui est√° um exemplo de diret√≥rios:\n/\n/etc/fstab\n/home/bruno\n/home/bruno/arquivo.txt\n/tmp\nA localiza√ß√£o desses arquivos e diret√≥rios √© chamada de caminho ou path. Observe no exemplo acima que tenho um arquivo.txt que fica no caminho /home/bruno, esse caminho tamb√©m √© conhecido como diret√≥rio home do usu√°rio.\nA navega√ß√£o no sistema de arquivos, assim como na vida real, √© √∫til se voc√™ souber onde est√° e para onde est√° indo. Para ver onde voc√™ est√°, voc√™ pode usar o comando pwd, este comando significa ‚Äúprint working directory‚Äù e apenas mostra em qual diret√≥rio voc√™ est√°, observe que o caminho vem do diret√≥rio raiz.\n$ pwd",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Pwd"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/5-file.html",
    "href": "conteudos/linha-de-comando/5-file.html",
    "title": "file",
    "section": "",
    "text": "file\nOk, acabamos de aprender sobre o comando touch, vamos voltar um pouco a isso. Voc√™ notou que o nome do arquivo n√£o estava de acordo com a extens√£o padr√£o, como voc√™ provavelmente j√° viu em outros sistemas operacionais como o Windows? Normalmente voc√™ esperaria um arquivo chamado banana.jpeg e um arquivo de imagem JPEG.\nNo Linux, os nomes de arquivos n√£o s√£o necess√°rios para representar o conte√∫do do arquivo. Voc√™ pode criar um arquivo chamado engra√ßado.gif que na verdade n√£o √© um GIF. Para descobrir que tipo de arquivo √© , voc√™ pode usar o comando file. Ele mostrar√° uma descri√ß√£o do conte√∫do do arquivo.\n$ file banana.jpg",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ File"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/6-cat.html",
    "href": "conteudos/linha-de-comando/6-cat.html",
    "title": "cat",
    "section": "",
    "text": "cat\nEstamos indo bem e vimos como navegar pelo sistema e arquivos, mas agora vamos aprender a ler um arquivo. Um comando simples para usar √© o comando cat, abrevia√ß√£o de concatenar, ele n√£o apenas exibe o conte√∫do do arquivo, mas pode combinar v√°rios arquivos e mostrar a sa√≠da deles.\n$ cat cores frutas\nN√£o √© √≥timo para visualizar arquivos grandes e destina-se apenas a conte√∫dos curtos. Existem muitas outras ferramentas que usamos para visualizar arquivos de texto maiores que discutiremos na pr√≥xima li√ß√£o.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Cat"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/8-history.html",
    "href": "conteudos/linha-de-comando/8-history.html",
    "title": "history",
    "section": "",
    "text": "history\nEm seu shell, h√° um hist√≥rico dos comandos que voc√™ digitou anteriormente, voc√™ pode realmente consultar esses comandos. Isso √© bastante √∫til quando voc√™ deseja localizar e executar um comando usado anteriormente sem digit√°-lo novamente.\n$ history\nQuer executar o mesmo comando que voc√™ fez antes, basta clicar na seta para cima ‚Üë.\nQuer executar o comando anterior sem digit√°-lo novamente? Usar !!. Se voc√™ digitou cat file1 e deseja execut√°-lo novamente, basta ir !! e executar√° o √∫ltimo comando que voc√™ executou.\nOutro atalho do hist√≥rico √© ctrl-R, este √© o comando de pesquisa reversa, se voc√™ pressionar ctrl-R e come√ßar a digitar partes do comando que deseja, ele mostrar√° as correspond√™ncias e voc√™ poder√° navegar por elas pressionando a tecla ctrl-R de novo. Depois de encontrar o comando que deseja usar novamente, basta pressionar a tecla Enter.\nNosso terminal est√° ficando um pouco confuso, n√£o? Vamos fazer uma pequena limpeza, use o comando clear para limpar sua tela.\n$ clear\nEnquanto falamos sobre coisas √∫teis, um dos recursos mais √∫teis em qualquer ambiente de linha de comando √© o Autocompletar usando o TAB. Se voc√™ come√ßar a digitar o in√≠cio de um comando, arquivo, diret√≥rio, etc. e pressionar a tecla TAB, ele ser√° preenchido automaticamente com base no que encontrar no diret√≥rio que voc√™ est√° pesquisando, desde que voc√™ n√£o tenha nenhum outro arquivo que comece com aqueles letras. Por exemplo, se voc√™ estava tentando executar o comando chrome, voc√™ pode digitar chr e pressionar TAB e ele preencher√° automaticamente o chrome.\nExperimente usar o TAB,¬†isso facilita e vida.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ History"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/12-rm.html",
    "href": "conteudos/linha-de-comando/12-rm.html",
    "title": "rm",
    "section": "",
    "text": "rm\nAgora acho que temos muitos arquivos, vamos remover alguns arquivos. Para remover arquivos voc√™ pode usar o comando rm. O comando rm (remove) √© usado para excluir arquivos e diret√≥rios.\n$ rm arquivo\nTome cuidado ao usar o rm, n√£o existe lixeira onde voc√™ possa restaurar os arquivos removidos. Depois que eles desaparecerem, eles desaparecer√£o para sempre, ent√£o tome cuidado.\nFelizmente, existem algumas medidas de seguran√ßa implementadas, ent√£o o cidad√£o comum n√£o pode simplesmente remover um monte de arquivos importantes. Os arquivos protegidos contra grava√ß√£o solicitar√£o confirma√ß√£o antes de exclu√≠-los. Se um diret√≥rio estiver protegido contra grava√ß√£o, ele tamb√©m n√£o ser√° facilmente removido.\nAgora, se voc√™ n√£o se importa com nada disso, voc√™ pode remover absolutamente v√°rios arquivos.\n$ rm -f arquivo1\nA op√ß√£o -f ou force diz ao rm para remover todos os arquivos, sejam eles protegidos contra grava√ß√£o ou n√£o, sem avisar o usu√°rio (desde que voc√™ tenha as permiss√µes apropriadas).\n$ rm -i arquivo\nAdicionar a op√ß√£o -i como muitos dos outros comandos informar√° se voc√™ deseja realmente remover os arquivos ou diret√≥rios.\n$ rm -r diret√≥rio\nVoc√™ n√£o pode simplesmente rm um diret√≥rio por padr√£o, voc√™ precisar√° usar a op√ß√£o -r (recursivo) para remover todos os arquivos e quaisquer subdiret√≥rios que ele possa ter.\nVoc√™ pode remover um diret√≥rio com o comando rmdir.\n$ rmdir dir\nUma dica para n√£o apagar dados indesejados com o rm, √© sempre recomendado usar o caminho absoluto do diret√≥rio. Por exemplo caso queira excluir os dados dentro da pasta ‚Äú/home/bruno/backup‚Äù, use:\n$ rm -rf /home/bruno/backup/\nIsso evita o erro de usar o comando rm * pensando estar dentro da pasta backup quando na verdade estava dentro de outra pasta. Lembre-se o terminal n√£o tem lixeira!",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Rm"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/11-mkdir.html",
    "href": "conteudos/linha-de-comando/11-mkdir.html",
    "title": "mkdir",
    "section": "",
    "text": "mkdir\nPrecisaremos de alguns diret√≥rios para armazenar todos esses arquivos nos quais estamos trabalhando. O comando mkdir (Make Directory) √© √∫til para isso, ele criar√° um diret√≥rio caso ele ainda n√£o exista. Voc√™ pode at√© criar v√°rios diret√≥rios ao mesmo tempo.\n$ mkdir livros textos\nVoc√™ tamb√©m pode criar v√°rios subdiret√≥rios ao mesmo tempo com a op√ß√£o -p.\n$ mkdir -p livros/linux/favoritos\nPerceba como o conhecimento do que j√° vimos ir√° se acumulando. podemos ver o uso de caminho relativo na cria√ß√£o de diret√≥rios.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Mkdir"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/4-pipe_and_tee.html",
    "href": "conteudos/arte-do-texto/4-pipe_and_tee.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Iremos conhecer o pipe (|) agora, vamos primeiro executar o comando:\n$ ls -lah /etc\n¬†Voc√™ dever√° ver uma lista muito longa de itens; √© at√© um pouco dif√≠cil de ler. Em vez de redirecionar essa sa√≠da para um arquivo, n√£o seria bom se pud√©ssemos ver a sa√≠da em outro comando como less, lembre que o less √© um paginador? Bem, n√≥s podemos!\n$ ls -lah /etc | less\nO operador pipe |, representado por uma barra vertical, permite-nos obter o stdout de um comando e torn√°-lo o stdin para outro processo. Nesse caso, pegamos o stdout do comando ls¬† e o direcionamos para a entrada do comando less. O comando pipe √© extremamente √∫til e continuaremos a us√°-lo por toda a eternidade.\nBem, e se eu quisesse escrever a sa√≠da do meu comando em dois fluxos diferentes? Isso √© poss√≠vel com o comando tee, nesse caso veremos a sa√≠da de ls na tela e tamb√©m ser√° armazenada no arquivo saida.txt:\n$ ls | tee saida.txt",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Pipe_And_Tee"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/5-env.html",
    "href": "conteudos/arte-do-texto/5-env.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Execute o seguinte comando, mas digite a vari√°vel como em letras mai√∫sculas:\n$ echo $HOME\nVoc√™ dever√° ver o caminho para o seu diret√≥rio home, o meu se parece com /home/bruno.\nE esse comando?\n$ echo $USER\nVoc√™ dever√° ver seu nome de usu√°rio! De onde vem essa informa√ß√£o? Est√° vindo de suas vari√°veis de ambiente.\nVoc√™ pode visualiz√°-los digitando:\n$ env\nIsso exibir√° muitas informa√ß√µes sobre as vari√°veis ‚Äã‚Äãde ambiente que est√£o definidas atualmente. Essas vari√°veis ‚Äã‚Äãcont√™m informa√ß√µes √∫teis que o shell e outros processos podem usar.\nVamos fazer um teste, crie uma vari√°vel qualquer e depois verifique com o comando env.\n$ export my_var=\"teste\"\n$ env\nO comando export no Linux √© usado para definir vari√°veis de ambiente e torn√°-las acess√≠veis para processos filhos do shell atual.\nUma vari√°vel particularmente importante √© a vari√°vel PATH. Voc√™ pode acessar essas vari√°veis ‚Äã‚Äãcolocando $ na frente do nome da vari√°vel, assim:\n$ echo $PATH\nIsso retorna uma lista de caminhos separados por dois pontos que seu sistema pesquisa quando procura um comando. Digamos que voc√™ baixe e instale manualmente um pacote da Internet e o coloque em um diret√≥rio n√£o padr√£o e queira executar esse comando, o sistema ir√° reclamar de comando n√£o encontrado. Mas voc√™ est√° olhando o bin√°rio em uma pasta e sabe que ele existe. O que est√° acontecendo √© que a vari√°vel $PATH n√£o verifica esse diret√≥rio onde este o bin√°rio, ent√£o est√° gerando um erro. Digamos que voc√™ tenha v√°rios bin√°rios que deseja executar nesse diret√≥rio. Voc√™ pode simplesmente modificar a vari√°vel PATH para incluir esse diret√≥rio em sua vari√°vel de ambiente PATH.",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Env"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/13-uniq.html",
    "href": "conteudos/arte-do-texto/13-uniq.html",
    "title": "Comandos √∫teis para manipula√ß√£o de texto",
    "section": "",
    "text": "Existem muitos comandos √∫teis para manipular texto no console. Um desses comandos √© o uniq, que √© uma ferramenta muito pr√°tica para eliminar linhas duplicadas em um arquivo.\n\n\nImagine que voc√™ tem um arquivo chamado arq.txt com v√°rias linhas duplicadas:\narq.txt\nlivro\nlivro\nrevista\nrevista\ncomputador\nSe voc√™ quiser remover essas linhas duplicadas, basta utilizar o comando uniq:\n$ uniq arq.txt\nlivro\nrevista\ncomputador\n\n\n\nSe voc√™ quiser saber quantas vezes cada linha aparece no arquivo, basta adicionar a op√ß√£o -c ao comando uniq:\n$ uniq -c arq.txt\n2 livro\n2 revista\n1 computador\n\n\n\nSe voc√™ quiser exibir apenas as linhas √∫nicas do arquivo, basta utilizar a op√ß√£o -u ao comando uniq:\n$ uniq -u arq.txt\ncomputador\n\n\n\nSe voc√™ quiser exibir apenas as linhas duplicadas do arquivo, basta utilizar a op√ß√£o -d ao comando uniq:\n$ uniq -d arq.txt\nlivro\nrevista",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Uniq"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/13-uniq.html#exemplo-de-uso",
    "href": "conteudos/arte-do-texto/13-uniq.html#exemplo-de-uso",
    "title": "Comandos √∫teis para manipula√ß√£o de texto",
    "section": "",
    "text": "Imagine que voc√™ tem um arquivo chamado arq.txt com v√°rias linhas duplicadas:\narq.txt\nlivro\nlivro\nrevista\nrevista\ncomputador\nSe voc√™ quiser remover essas linhas duplicadas, basta utilizar o comando uniq:\n$ uniq arq.txt\nlivro\nrevista\ncomputador",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Uniq"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/13-uniq.html#contagem-de-ocorr√™ncias",
    "href": "conteudos/arte-do-texto/13-uniq.html#contagem-de-ocorr√™ncias",
    "title": "Comandos √∫teis para manipula√ß√£o de texto",
    "section": "",
    "text": "Se voc√™ quiser saber quantas vezes cada linha aparece no arquivo, basta adicionar a op√ß√£o -c ao comando uniq:\n$ uniq -c arq.txt\n2 livro\n2 revista\n1 computador",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Uniq"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/13-uniq.html#exibi√ß√£o-de-valores-√∫nicos",
    "href": "conteudos/arte-do-texto/13-uniq.html#exibi√ß√£o-de-valores-√∫nicos",
    "title": "Comandos √∫teis para manipula√ß√£o de texto",
    "section": "",
    "text": "Se voc√™ quiser exibir apenas as linhas √∫nicas do arquivo, basta utilizar a op√ß√£o -u ao comando uniq:\n$ uniq -u arq.txt\ncomputador",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Uniq"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/13-uniq.html#exibi√ß√£o-de-valores-duplicados",
    "href": "conteudos/arte-do-texto/13-uniq.html#exibi√ß√£o-de-valores-duplicados",
    "title": "Comandos √∫teis para manipula√ß√£o de texto",
    "section": "",
    "text": "Se voc√™ quiser exibir apenas as linhas duplicadas do arquivo, basta utilizar a op√ß√£o -d ao comando uniq:\n$ uniq -d arq.txt\nlivro\nrevista",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Uniq"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/11-tail.html",
    "href": "conteudos/arte-do-texto/11-tail.html",
    "title": "Comandos √∫teis para visualizar arquivos: tail e head",
    "section": "",
    "text": "Comandos √∫teis para visualizar arquivos: tail e head\nO comando tail funciona de forma semelhante ao comando head. Mas ele permite visualizar as √∫ltimas 10 linhas de um arquivo por padr√£o.\nExemplo:\n$ tail /var/log/syslog\nComo no head o tail, voc√™ pode alterar o n√∫mero de linhas que deseja visualizar.\nExemplo:\n$ tail -n 15 /var/log/syslog\nUma op√ß√£o interessante √© a flag -f (follow). Ela permite seguir o arquivo √† medida que ele cresce, bom para monitorar um servi√ßo em tempo real.\nExemplo:\n$ tail -f /var/log/syslog\nEnquanto voc√™ interage com seu sistema, o arquivo syslog estar√° constantemente mudando. Com tail -f, voc√™ pode acompanhar tudo o que √© adicionado a esse arquivo.",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Tail"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/8-paste.html",
    "href": "conteudos/arte-do-texto/8-paste.html",
    "title": "linuxteclab",
    "section": "",
    "text": "O comando paste no Linux √© utilizado para combinar linhas de diferentes arquivos de forma horizontal, ou seja, ele ‚Äúcola‚Äù o conte√∫do das linhas correspondentes de dois ou mais arquivos lado a lado, separando-as por um delimitador (por padr√£o, o caractere de tabula√ß√£o).\nVamos tomar como exemplo os dois arquivos a seguir:\nArq1.txt\n1\n2\n3\nArq2.txt\na\nb\nc\nUsando o paste.\n$ paste arqu1.txt arq2.txt\nComo resultado teria:\n1   a\n2   b\n3   c",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Paste"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/2-stdin.html",
    "href": "conteudos/arte-do-texto/2-stdin.html",
    "title": "stdin (Standard in)",
    "section": "",
    "text": "stdin (Standard in)\nOk vimos que temos o stdout que podemos usar, como um arquivo ou a tela como forma de sa√≠da. Bem, tamb√©m existem diferentes fluxos de entrada padr√£o (stdin) que podemos usar. Sabemos que temos stdin de dispositivos como o teclado, mas podemos usar arquivos, sa√≠da de outros processos e do terminal tamb√©m, vamos ver um exemplo.\nVamos usar o arquivo arq.txt neste exemplo, lembre-se de que ele continha o texto Hello World.\n$ cat &lt; arq.txt\nExecutando o comando vemos que o arq.txt √© colocado no stdin do comando cat, e o conte√∫do do arquivo √© mostrado na tela.\nPodemos agora enviar o stdout do comando cat para um arquivo.\n$ cat &lt; arq.txt &gt; saida.txt",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Stdin"
    ]
  },
  {
    "objectID": "conteudos/processos/3 - Sobre processos.html",
    "href": "conteudos/processos/3 - Sobre processos.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Antes de mergulhar em aplica√ß√µes pr√°ticas de processo, precisamos entender o que s√£o e como funcionam. Este tema pode ser confuso, pois estamos mergulhando nos detalhes.\nUm processo, como disse antes, √© um programa em execu√ß√£o no sistema, seja mais preciso, √© o sistema alocando mem√≥ria, processador, I/O para que o programa execute. Um processo √© uma inst√¢ncia de um programa em execu√ß√£o - abra tr√™s janelas de terminal, em duas janelas, execute o comando cat sem passar op√ß√µes (o processo do cat ficar√° aberto porque espera stdin). Agora, em uma janela adicional, execute: ps aux | grep cat. Voc√™ ver√° que h√° dois processos para o cat, embora estejam executando o mesmo programa.\n√â o kernel que est√° encarregado dos processos. Quando executamos um programa, o kernel carrega o c√≥digo do programa na mem√≥ria, determina e aloca recursos e, em seguida, mant√©m controle sobre cada processo. O kernel sabe:\n\nO status do processo\nOs recursos que o processo est√° usando e recebe\nO propriet√°rio do processo\nTratamento de sinais (mais sobre isso posteriormente)\nE basicamente, tudo o mais\n\nTodos os processos tentam pegar um peda√ßo desses ‚Äúrecursos‚Äù, √© o trabalho do kernel garantir que processos recebam a quantidade certa de recursos com base na demanda do processo. Quando um processo termina, os recursos que ele usou agora est√£o livre para outros processos.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Sobre Processos"
    ]
  },
  {
    "objectID": "conteudos/processos/6 - Sinais no Linux.html",
    "href": "conteudos/processos/6 - Sinais no Linux.html",
    "title": "Sinais no sistema operacional",
    "section": "",
    "text": "Sinais no sistema operacional\nO sistema operacional emite um sinal (ou notification) para um processo sempre que algo acontece. Por que os sinais? Eles s√£o interrup√ß√µes de software e t√™m in√∫meras utiliza√ß√µes: * O usu√°rio pode digitar um caractere especial no terminal (Ctrl+C ou Ctrl+Z) para matar, interromper ou suspender processos * Problemas de hardware podem ocorrer e o kernel deseja notificar o processo * Problemas de software podem ocorrer e o kernel deseja notificar o processo * S√£o basicamente formas pelas quais processos podem se comunicar\n\n\nProcessamento de sinais\nQuando um sinal √© gerado por um evento, √© ent√£o entregue a um processo, √© considerado em estado pendente at√© ser entregue. Quando o processo √© executado, o sinal ser√° entregue. No entanto, os processos t√™m m√°scaras de sinal e podem configurar a entrega de sinais para ser bloqueada se especificado. Quando um sinal √© entregue, um processo pode fazer v√°rias coisas: * Ignorar o sinal * ‚ÄúCapturar‚Äù o sinal e executar uma rotina de tratamento espec√≠fica * O processo pode ser interrompido, ao inv√©s da chamada de sistema de sa√≠da normal * Blockar o sinal, dependendo da m√°scara de sinal\nSinais comuns Cada sinal √© definido por inteiros com nomes simb√≥licos no formato SIGxxx. Algumas das principais sinais s√£o: * SIGHUP ou HUP ou 1: Encerramento do conector * SIGINT ou INT ou 2: Interrup√ß√£o * SIGKILL ou KILL ou 9: Parar * SIGSEGV ou SEGV ou 11: Erro de segmenta√ß√£o * SIGTERM ou TERM ou 15: Encerramento por software * SIGSTOP ou STOP: Parar\nOs n√∫meros dos sinais podem variar, portanto √© comum referir-se a eles por seus nomes. Alguns sinais s√£o imposs√≠veis de bloquear, um exemplo √© o sinal SIGKILL. O sinal de parar destr√≥i o processo.\nExemplo de utiliza√ß√£o de sinais Para testar o funcionamento dos sinais, execute o comando kill seguido do n√∫mero do sinal desejado. Por exemplo, para gerar o sinal de parada (SIGTERM) para um processo, use kill 15 &lt;nome_do_processo&gt;.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Sinais No Linux"
    ]
  },
  {
    "objectID": "conteudos/processos/2 - Controlando o Terminal.html",
    "href": "conteudos/processos/2 - Controlando o Terminal.html",
    "title": "Voltando ao terminal de controle",
    "section": "",
    "text": "Vimos o campo TTY na sa√≠da do comando ps. O TTY √© o terminal que executou o comando.\nExistem dois tipos de terminais: dispositivos de terminal regulares e dispositivos de pseudo terminal. Um dispositivo de terminal regular √© um dispositivo de terminal nativo que voc√™ pode digitar e enviar sa√≠da para o seu sistema. Isso pode soar como a aplica√ß√£o de terminal que voc√™ est√° lan√ßando para acessar a sua shell, mas n√£o √©.\nVamos adiantar um passo e voc√™ ver√° como tudo isso se desenvolve. Digite Ctrl-Alt-F1 para se conectar ao TTY1 (a primeira.console virtual), voc√™ notar√° que n√£o h√° nada exceto o terminal, sem gr√°ficos, etc. Isso √© considerado um dispositivo de terminal regular. Voc√™ pode sair desta modalidade pressionando Ctrl-Alt-F7.\nUm pseudo terminal √© o que voc√™ tem sido usado para trabalhar, pode ser o terminator, qterminal, gnome terminal, etc‚Ä¶ Eles emulam terminais com janela de shell terminal e s√£o denotados por PTS. Se voc√™ olhar novamente para a sa√≠da do ps, ver√° o processo da sua shell sob pts/*.\n\nVoltando ao terminal de controle\nProcessos s√£o geralmente ligados a um terminal de controle. Por exemplo, se voc√™ estivesse executando um programa em sua janela de shell, como o comando find, e fechou a janela, o seu processo tamb√©m iria com ele.\nExistem processos especiais como processos de demons, que s√£o processos especiais que est√£o mantendo o sistema em funcionamento. Eles come√ßam durante a inicializa√ß√£o do sistema e usualmente s√£o terminados quando o sistema √© encerrado. Eles funcionam em segundo plano e, j√° que n√£o queremos que esses processos especiais sejam terminados, eles n√£o est√£o ligados a um terminal de controle. Na sa√≠da do ps, o TTY √© listado como ?, indicando que n√£o tem um terminal de controle.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controlando O Terminal"
    ]
  },
  {
    "objectID": "conteudos/processos/9 - Controle de Job.html",
    "href": "conteudos/processos/9 - Controle de Job.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Imagine que voc√™ est√° trabalhando em uma janela de terminal √∫nica e est√° executando um comando que est√° levando muito tempo. N√£o pode interagir com o shell at√© que seja completo, mas quer continuar trabalhando no seu computador. Felizmente, podemos controlar como nossos processos s√£o executados com jobs:",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controle De Job"
    ]
  },
  {
    "objectID": "conteudos/processos/9 - Controle de Job.html#envio-de-um-job-para-o-background",
    "href": "conteudos/processos/9 - Controle de Job.html#envio-de-um-job-para-o-background",
    "title": "linuxteclab",
    "section": "Envio de um job para o background",
    "text": "Envio de um job para o background\nUsando um ampersand (&) ao fim do comando, voc√™ poder√° execut√°-lo em segundo plano e continuar usando o shell. Vamos ver um exemplo:\n$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controle De Job"
    ]
  },
  {
    "objectID": "conteudos/processos/9 - Controle de Job.html#visualizar-todos-os-jobs-de-background",
    "href": "conteudos/processos/9 - Controle de Job.html#visualizar-todos-os-jobs-de-background",
    "title": "linuxteclab",
    "section": "Visualizar todos os jobs de background",
    "text": "Visualizar todos os jobs de background\nAgora voc√™ pode visualizar os jobs que enviou para o background.\n$ jobs\n[1]    Running     sleep 1000 &\n[2]-   Running     sleep 1001 &\n[3]+   Running     sleep 1002 &\nIsso mostrar√° o ID do job na primeira coluna, seguido pelo status e o comando que rodou. o sinal de ‚Äú+‚Äù pr√≥ximo ao job ID significa que esse √© o job mais recente iniciado. J√° o sinal de ‚Äô‚Äú-‚Äù indica o segundo comando mais recente.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controle De Job"
    ]
  },
  {
    "objectID": "conteudos/processos/9 - Controle de Job.html#mandando-um-job-j√°-iniciado-para-o-background",
    "href": "conteudos/processos/9 - Controle de Job.html#mandando-um-job-j√°-iniciado-para-o-background",
    "title": "linuxteclab",
    "section": "Mandando um job j√° iniciado para o background",
    "text": "Mandando um job j√° iniciado para o background\nSe voc√™ j√° executou um job e quer enviar para o background, n√£o precisa termin√°-lo e come√ßar novamente. Primeiro, suspenda o job com Ctrl-Z, ent√£o rode o comando bg assim o job ser√° enviado para o background.\nbruno@angus ~ $ sleep 1003\n^Z\n[4]+    Stopped     sleep 1003\nbruno@angus ~ $ bg\n[4]+    sleep 1003 &\nbruno@angus ~ $ jobs\n[1]    Running     sleep 1000 &\n[2]    Running     sleep 1001 &\n[3]-   Running     sleep 1002 &\n[4]+   Running     sleep 1003 &",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controle De Job"
    ]
  },
  {
    "objectID": "conteudos/processos/9 - Controle de Job.html#movendo-um-job-do-background-para-o-foreground",
    "href": "conteudos/processos/9 - Controle de Job.html#movendo-um-job-do-background-para-o-foreground",
    "title": "linuxteclab",
    "section": "Movendo um job do background para o foreground",
    "text": "Movendo um job do background para o foreground\nPara mover um job fuera do background, especifique o ID do job que voc√™ deseja. Se voc√™ executar fg sem par√¢metros, ele trar√° o job mais recente para o foreground (o job com o sinal + ao lado dele)\n$ fg %1",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controle De Job"
    ]
  },
  {
    "objectID": "conteudos/processos/9 - Controle de Job.html#matando-jobs-de-background",
    "href": "conteudos/processos/9 - Controle de Job.html#matando-jobs-de-background",
    "title": "linuxteclab",
    "section": "Matando jobs de background",
    "text": "Matando jobs de background\nSimilarmente, voc√™ pode usar a mesma forma para matar processos usando IDs de Job.\nkill %1\nEm caso de d√∫vida, √© sempre recomend√°vel consultar o manual do jobs com man jobs para obter mais informa√ß√µes.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Controle De Job"
    ]
  },
  {
    "objectID": "conteudos/processos/5 - Finaliza√ß√£o de processos.html",
    "href": "conteudos/processos/5 - Finaliza√ß√£o de processos.html",
    "title": "Processos √ìrf√£os",
    "section": "",
    "text": "Agora que sabemos o que acontece quando um processo √© criado, o que est√° acontecendo quando n√£o precisamos mais dele? Um processo pode sair usando o chamada de sistema _exit, o que liberar√° os recursos que o processo estava usando para realoca√ß√£o. Quando um processo est√° pronto para terminar, ele avisa o kernel por que est√° terminando com algo chamado um status de t√©rmino. A maioria comumente, um status de 0 significa que o processo teve sucesso. No entanto, isso n√£o √© o suficiente para terminar completamente um processo. O processo pai precisa confirmar a t√©rmino do processo filho usando a chamada de sistema wait e o que isso faz √© verificar o status de t√©rmino do processo filho. Eu sei que √© um pouco macabro pensar nisso, mas a chamada de sistema wait √© uma necessidade, afinal, qual pai n√£o gostaria de saber como seu filho morreu? H√° outro jeito de terminar um processo e isso envolve usar sinais, o que discutiremos em breve.\n\nProcessos √ìrf√£os\nQuando um processo pai morre antes de um processo filho, o kernel sabe que n√£o vai obter uma chamada de sistema wait, ent√£o em vez disso, os processos tornam-se ‚Äú√≥rf√£os‚Äù e s√£o collocados sob o cuidado de init (lembre-se, a ‚Äúm√£e de todos os processos‚Äù). Init ir√° realizar a chamada de sistema wait para esses √≥rf√£os eventualmente, permitindo que eles morram.\n\n\nProcessos Zumbis\nO que acontece quando um processo filho termina e o processo pai n√£o fez uma chamada de sistema wait? Ainda queremos saber como um processo filho terminou, ent√£o embora o processo filho tenha terminado, o kernel converte o processo filho em um processo zumbi. Os recursos utilizados pelo processo filho est√£o ainda liberados para outros processos, no entanto, h√° ainda uma entrada na tabela de processos para esse zumbi. Processos zumbis tamb√©m n√£o podem ser terminados, pois est√£o tecnicamente ‚Äúmortos‚Äù, portanto, voc√™ n√£o pode usar sinais para mat√°-los. Se o processo pai realizar uma chamada de sistema wait, o zumbi desaparecer√°. Se o processo pai n√£o realizar uma chamada de sistema wait, init adotar√° o zumbi e realizar√° automaticamente wait e remover√° o zumbi. Ter muitos processos zumbis pode ser ruim, pois eles ocupam espa√ßo na tabela de processos, se ela se preencher, isso impedir√° que outros processos iniciem. ***",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Finaliza√ß√£o De Processos"
    ]
  },
  {
    "objectID": "conteudos/processos/1- Comando ps.html",
    "href": "conteudos/processos/1- Comando ps.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Processos s√£o programas que est√£o sendo executados na sua m√°quina. Eles s√£o gerenciados pelo kernel e cada processo tem um ID associado a ele, chamado de ID de processo (PID). Esse PID √© atribu√≠do na ordem em que os processos s√£o criados.\nexecute o comando ps para ver uma lista de processos em execu√ß√£o:\n$ ps\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\nIsso mostra um quadro dos processos atuais, com informa√ß√µes relevantes para o administrador da m√°quina:\n\nPID: ID de processo\nTTY: Terminal de controle associado ao processo\nSTAT: C√≥digo de status do processo\nTIME: Tempo de uso do CPU total\nCMD: Nome do execut√°vel/comando\n\nSe voc√™ revisar a p√°gina do manual do comando ps, ver√° que h√° muitas op√ß√µes de comando que voc√™ pode passar, que variar√£o dependendo das op√ß√µes que voc√™ deseja usar - BSD, GNU ou Unix. Em minha opini√£o, o estilo BSD √© mais popular para usar, por isso vamos trabalhar com isso. Se voc√™ estiver curioso, a diferen√ßa entre estilos √© o n√∫mero de tra√ßos/h√≠fens que voc√™ usa nas op√ß√µes.\n$ ps aux\nO caractere a exibe todos os processos em execu√ß√£o, incluindo os que est√£o being executados por outros usu√°rios. O caractere u mostra mais detalhes sobre os processos. E finalmente, o caractere x lista todos os processos que n√£o t√™m um terminal associado, que s√£o os programas mais comuns em processos daemon que s√£o executados como parte do in√≠cio do sistema.\nVoc√™ notar√° que est√° vendo muitos campos agora, n√£o h√° necessidade de memorizar todos eles.\n\nUSER: Usu√°rio efetivo (o que estamos usando).\nPID: ID de processo.\n%CPU: CPU tempo usado dividido pelo tempo que o processo tem estado rodando.\n%MEM: Raz√£o da tamanho de conjunto residente do processo sobre a mem√≥ria f√≠sica da m√°quina.\nVSZ: Uso de mem√≥ria virtual do processo.\nRSS: Tamanho de conjunto residente, a mem√≥ria f√≠sica n√£o substitu√≠vel que um processo usou.\nTTY: Terminal de controle associado ao processo.\nSTAT: C√≥digo de status do processo.\nSTART: Tempo de in√≠cio do processo.\nTIME: Tempo de uso do CPU total.\nCOMMAND: Nome do execut√°vel/comando.\n\nO comando ps pode se tornar um pouco confuso para ser lido, por ora os campos que vamos usar mais frequentemente s√£o PID, STAT e COMMAND.\nOutra ferramenta muito √∫til √© o comando top, que fornece informa√ß√µes em tempo real sobre os processos em execu√ß√£o no seu sistema em vez de um instant√¢neo. Por padr√£o, voc√™ ter√° uma atualiza√ß√£o a cada 10 segundos. O comando top √© uma ferramenta extremamente √∫til para ver quais processos est√£o usando muitos de seus recursos.\n$ top",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Comando Ps"
    ]
  },
  {
    "objectID": "conteudos/manipulacao-de-usuario/6- Gerenciamento de usu√°rios.html",
    "href": "conteudos/manipulacao-de-usuario/6- Gerenciamento de usu√°rios.html",
    "title": "Adicionar Usu√°rios",
    "section": "",
    "text": "Muitas infraestruturas empresariais utilizam sistemas de gerenciamento para gerenciar usu√°rios, contas e senhas. No entanto, em um computador local, h√° comandos √∫teis para gerenciar usu√°rios.\n\nAdicionar Usu√°rios\nPode ser utilizado o comando adduser ou useradd. O comando adduser apresenta recursos mais √∫teis, como criar um diret√≥rio home e outros. Existem arquivos de configura√ß√£o para adicionar novos usu√°rios e podem ser personalizados de acordo com as necessidades do usu√°rio padr√£o.\nExemplo:\n$ sudo useradd bob\nVoc√™ ver√° que o comando acima cria uma entrada no arquivo /etc/passwd para bob, configura grupos padr√£o e adiciona uma entrada no arquivo /etc/shadow.\n\n\nRemover Usu√°rios\nPara remover um usu√°rio, voc√™ pode usar o comando userdel.\nExemplo:\n$ sudo userdel bob\nEste comando basicamente desfaz as altera√ß√µes feitas pelo comando useradd.\n\n\nAlterar Senhas\n$ passwd bob\nIsso permitir√° que voc√™ altere a senha do pr√≥prio usu√°rio ou de outro usu√°rio (se voc√™ for root).\nNota: √â recomend√°vel usar o comando adduser em vez de useradd, pois o primeiro √© mais f√°cil de usar e apresenta recursos mais avan√ßados.",
    "crumbs": [
      "Home",
      "üìÇ Manipulacao De Usuario",
      "‚úÖ Gerenciamento De Usu√°rios"
    ]
  },
  {
    "objectID": "conteudos/manipulacao-de-usuario/4- Arquivo shadow.html",
    "href": "conteudos/manipulacao-de-usuario/4- Arquivo shadow.html",
    "title": "linuxteclab",
    "section": "",
    "text": "O arquivo /etc/shadow tem como objetivo armazenar informa√ß√µes sobre autentica√ß√£o de usu√°rios. Para ler este arquivo, √© necess√°rio ter permiss√µes de leitura como superusu√°rio.\nExemplo:\n$ sudo cat /etc/shadow\nroot:MyEPTEa$6Nonsense:15000:0:99999:7::: \nObserve que o conte√∫do √© muito semelhante ao do arquivo /etc/passwd, mas o campo de senha apresenta uma senha criptografada. Os campos s√£o separados por coluns, como segue:\n\n1: Nome de usu√°rio.\n2: Senha criptografada.\n3: Data da √∫ltima altera√ß√£o da senha - (exprimida em dias desde 1¬∫ de janeiro de 1970). Se for apresentado um zero, isso significa que o usu√°rio deve alterar sua senha ao logging em seguida.\n4: Per√≠odo m√≠nimo para altera√ß√£o da senha - (em dias) - o per√≠odo que um usu√°rio precisar√° esperar antes de poder alterar sua senha novamente.\n5: Per√≠odo m√°ximo para altera√ß√£o da senha - (em dias) - o per√≠odo m√°ximo antes que um usu√°rio tenha que alterar sua senha.\n6: Per√≠odo de aviso para senha (em dias) - o per√≠odo antes que uma senha expira.\n7: Per√≠odo de inatividade para senha (em dias) - o per√≠odo ap√≥s a senha expirar para permitir que o usu√°rio logging com a senha.\n8: Data de expira√ß√£o do conta - (data em que o usu√°rio n√£o poder√° logar)\n9: Campo reservado para uso futuro\n\n√â importante notar que, em muitas das distribui√ß√µes de hoje, a autentica√ß√£o de usu√°rios n√£o depende apenas do arquivo /etc/shadow, existem outros mecanismos em uso, como as M√≥dulas de Autentica√ß√£o Pluggable (PAM), que substituem a autentica√ß√£o.",
    "crumbs": [
      "Home",
      "üìÇ Manipulacao De Usuario",
      "‚úÖ Arquivo Shadow"
    ]
  },
  {
    "objectID": "conteudos/manipulacao-de-usuario/1- Usuario e grupo.html",
    "href": "conteudos/manipulacao-de-usuario/1- Usuario e grupo.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Em qualquer sistema operacional tradicional, existem usu√°rios e grupos. Eles t√™m como √∫nico prop√≥sito gerenciar o acesso e as permiss√µes. Quando um processo √© executado, ele executar√° como propriet√°rio do processo. O acesso a arquivos e a propriedade tamb√©m s√£o dependentes das permiss√µes. Voc√™ n√£o quer que outro usu√°rio veja seus arquivos.\nCada usu√°rio tem seu pr√≥prio diret√≥rio home, onde seus arquivos espec√≠ficos s√£o armazenados. Esse diret√≥rio pode ser encontrado em /home/usuario, mas pode variar dependendo da distribui√ß√£o e configura√ß√£o.\nO sistema usa IDs de usu√°rio (UID) para gerenciar os usu√°rios. Os nomes de usu√°rio s√£o uma forma de associar usu√°rios com identifica√ß√£o, mas o sistema identifica os usu√°rios por suas IDs. O sistema tamb√©m usa grupos para gerenciar permiss√µes. Os grupos s√£o apenas conjuntos de usu√°rios com permiss√µes definidas por esse grupo e s√£o identificados pelo sistema com seu ID de grupo (GID).\nNo Linux, voc√™ tamb√©m encontrar√° usu√°rios al√©m dos humanos normais que usam o sistema. Esses usu√°rios podem ser de servi√ßos de sistema, daemons que executam processos cont√≠nuos para manter o sistema funcionando. Um dos usu√°rios mais importantes √© o root ou superusu√°rio. O root √© o usu√°rio mais poderoso do sistema e pode acessar qualquer arquivo e come√ßar ou parar qualquer processo. Por essa raz√£o, √© perigoso operar como root o tempo todo, pois voc√™ pode remover arquivos cr√≠ticos do sistema. Felizmente, se precisar de acesso root e um usu√°rio tiver acesso root, ele pode executar um comando como root em vez disso usando o comando sudo. O comando sudo √© usado para executar um comando com acesso root, assim √© poss√≠vel dar esse acesso para v√°rios usu√°rios.\nTente visualizar um arquivo protegido como /etc/shadow:\n$ cat /etc/shadow\nObserve como voc√™ recebe um erro de permiss√£o negada. Olhe as permiss√µes com:\n$ ls -la /etc/shadow\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\nN√£o vamos abordar permiss√µes ainda, mas o que est√° acontecendo √© que o arquivo √© propriet√°rio do root e voc√™ precisar√° de acesso root ou ser membro do grupo shadow para ler o conte√∫do. Agora, execute o comando com sudo:\n$ sudo cat /etc/shadow\nAgora voc√™ poder√° ver o conte√∫do do arquivo, caso esteja com permiss√µes de execu√ß√£o do sudo, mas antes ter√° que usar sua senha!",
    "crumbs": [
      "Home",
      "üìÇ Manipulacao De Usuario",
      "‚úÖ Usuario E Grupo"
    ]
  },
  {
    "objectID": "conteudos/permissoes/1 - Permiss√µes.html",
    "href": "conteudos/permissoes/1 - Permiss√µes.html",
    "title": "linuxteclab",
    "section": "",
    "text": "J√° vimos que os arquivos possuem diferentes permiss√µes ou modos de arquivo. Vamos explorar um exemplo:\n$ ls -l Desktop/\ndrwxr-xr-x 2 bruno linuxteclab 4096 Dec 12 1:45 .\nUma permiss√£o de arquivo se comp√µe de quatro partes. A primeira √© o tipo de arquivo, representada pelo primeiro caractere da permiss√£o. No nosso caso, estamos examinando um diret√≥rio, o tipo de arquivo √© denotado pela letra ‚Äúd‚Äù. Em geral, voc√™ ver√° um ‚Äú-‚Äù para um arquivo regular.\nAs pr√≥ximas tr√™s partes da permiss√£o de arquivo s√£o as permiss√µes reais. As permiss√µes s√£o agrupadas em 3 bits cada. Os primeiros 3 bits representam as permiss√µes do usu√°rio, em seguida, as permiss√µes do grupo e, por fim, as permiss√µes de outros. Adicionei um pipe para facilitar a diferencia√ß√£o.\nd | rwx | r-x | r-x\nCada caractere representa uma permiss√£o diferente:\n\nr: leitura\nw: escrita\nx: execu√ß√£o (ou seja, um programa execut√°vel)\n-: vazio ou sem permiss√£o\n\nNo exemplo acima, vemos que o usu√°rio ‚Äúbruno‚Äù tem permiss√µes de leitura, escrita e execu√ß√£o no arquivo. O grupo ‚Äúlinuxteclab‚Äù tem permiss√µes de leitura e execu√ß√£o. Por fim, os outros usu√°rios (ou seja, todos os demais) t√™m permiss√µes de leitura e execu√ß√£o.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Permiss√µes"
    ]
  },
  {
    "objectID": "conteudos/permissoes/8 - Sticky Bit.html",
    "href": "conteudos/permissoes/8 - Sticky Bit.html",
    "title": "O bit de permiss√£o stick: um recurso √∫til para diret√≥rios compartilhados",
    "section": "",
    "text": "O bit de permiss√£o stick: um recurso √∫til para diret√≥rios compartilhados\nUm √∫ltimo bit de permiss√£o especial: o bit stick. Quando um bit stick √© configurado em um arquivo ou diret√≥rio, isso significa que apenas o propriet√°rio do arquivo ou o usu√°rio raiz podem exclu√≠-lo ou modific√°-lo. Isso √© muito √∫til em diret√≥rios compartilhados. Veja o exemplo abaixo:\n$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\nNota-se um bit de permiss√£o especial ao final, o caractere t. Isso significa que qualquer usu√°rio pode adicionar arquivos, criar arquivos ou modificar arquivos no diret√≥rio /tmp, mas apenas o usu√°rio raiz pode excluir o diret√≥rio /tmp.\n\n\nModificar o bit stick\nPara modificar o bit stick, use o comando chmod com a op√ß√£o -t e o par√¢metro +:\n$ sudo chmod +t mydir\n$ sudo chmod 1755 mydir\nA representa√ß√£o num√©rica para o bit stick √© 1.\nNota que o bit stick √© frequentemente utilizado em diret√≥rios tempor√°rios (como `/tmp`), pois permite que v√°rios usu√°rios criem e lerem arquivos nele, mas impede que um usu√°rio exclua o diret√≥rio todo da forma que deseja.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Sticky Bit"
    ]
  },
  {
    "objectID": "conteudos/permissoes/6 - Setgid.html",
    "href": "conteudos/permissoes/6 - Setgid.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Similarmente ao bit de permiss√£o ‚ÄúSet User ID‚Äù, h√° um bit de permiss√£o ‚ÄúSet Group ID‚Äù (SGID). Este bit permite que um programa execute como se fosse um membro do grupo correspondente.\nVamos verificar um exemplo:\n$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\nAgora podemos ver que o bit de permiss√£o est√° configurado no conjunto de permiss√µes do grupo.\nModificando o SGID\n$ sudo chmod g+s exemplo.txt\n$ sudo chmod 2555 exemplo.txt\nA representa√ß√£o num√©rica para SGID √© 2.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Setgid"
    ]
  },
  {
    "objectID": "conteudos/permissoes/2 - Modificando Permiss√µes.html",
    "href": "conteudos/permissoes/2 - Modificando Permiss√µes.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Alterar permiss√µes √© um processo relativamente simples com o comando chmod. Primeiramente, escolha qual conjunto de permiss√µes deseja alterar, usu√°rio, grupo ou outros. Voc√™ pode adicionar ou remover permiss√µes com um ‚Äú+‚Äù ou ‚Äú-‚Äù, vamos dar uma olhada em alguns exemplos.\nAdicionar uma bit de permiss√£o a um arquivo\n$ chmod u+x file\nO comando acima se l√™ assim: ‚Äúaltere as permiss√µes do arquivo file adicionando o bit de permiss√£o execut√°vel ao conjunto de permiss√µes do usu√°rio‚Äù. Agora, o usu√°rio tem permiss√£o execut√°vel para este arquivo!\nRemover uma bit de permiss√£o a um arquivo\n$ chmod u-x myfile\nAdicionar m√∫ltiplas bits de permiss√£o a um arquivo\n$ chmod ug+w\nH√° outra forma de alterar permiss√µes usando o formato num√©rico. Essa maneira permite alterar todas as permiss√µes de uma s√≥ vez. Em vez de usar ‚Äúr‚Äù, ‚Äúw‚Äù ou ‚Äúx‚Äù para representar permiss√µes, voc√™ utilizar√° uma representa√ß√£o num√©rica para um conjunto de permiss√µes √∫nico. Agora, n√£o √© necess√°rio especificar o grupo com ‚Äúg‚Äù ou o usu√°rio com ‚Äúu‚Äù.\nAs representa√ß√µes num√©ricas est√£o abaixo:\n\n4: permiss√£o de leitura\n2: permiss√£o de escrita\n1: permiss√£o de execu√ß√£o\n\nVamos dar uma olhada em um exemplo:\n$ chmod 755 file\nPreste aten√ß√£o, o que estamos dando a permiss√µes para este arquivo? Vamos quebrar isso, portanto, agora 755 abrange as permiss√µes para todos os conjuntos. O primeiro n√∫mero (7) representa as permiss√µes do usu√°rio, o segundo n√∫mero (5) representa as permiss√µes do grupo e o √∫ltimo n√∫mero (5) representa as permiss√µes de outros. Lembre-se de que agora estamos combinando todas as permiss√µes em um n√∫mero √∫nico, portanto, voc√™ precisar√° fazer um pouco de matem√°tica. 7 = 4 + 2 + 1, assim 7 √© as permiss√µes do usu√°rio e ele tem permiss√£o de leitura, escrita e execu√ß√£o 5 = 4 + 1, o grupo tem permiss√£o de leitura e execu√ß√£o 5 = 4 + 1, e todos os outros usu√°rios tem permiss√£o de leitura e execu√ß√£o\nLembre-se de que n√£o √© uma boa ideia mudar as permiss√µes aleatoriamente, pois isso pode expor um arquivo sens√≠vel para que todos possam modific√°-lo. No entanto, se voc√™ precisar alterar as permiss√µes, apenas tome cuidado ao usar o comando chmod.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Modificando Permiss√µes"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Aprenda Linux com conte√∫do estruturado e organizado.\nEste projeto √© inspirado no site https://linuxjourney.com/\nConte√∫do produzido por Bruno Caires."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "conteudos/permissoes/3 - Alterando propriet√°rio.html",
    "href": "conteudos/permissoes/3 - Alterando propriet√°rio.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Al√©m de alterar os permiss√µes de um arquivo, voc√™ tamb√©m pode alterar a propriedade do usu√°rio e do grupo associados ao arquivo.\nAlterar propriet√°rio do usu√°rio\nsudo chown linuxteclab exemplos.txt\nEste comando definir√° o usu√°rio dono do arquivo exemplos.txt como linuxteclab.\nAlterar grupo do arquivo\nsudo chgrp TI arq.txt\nEste comando definir√° o grupo do arquivo arq.txt como TI.\nAlterar propriet√°rio do usu√°rio e grupo ao mesmo tempo\nSe voc√™ usar o car√°cter de dois pontos ap√≥s o usu√°rio, poder√° alterar usu√°rio e grupo ao mesmo tempo.\nsudo chown linuxteclab:TI exemplos.txt",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Alterando Propriet√°rio"
    ]
  },
  {
    "objectID": "conteudos/permissoes/4 - Umask.html",
    "href": "conteudos/permissoes/4 - Umask.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Todo arquivo que √© criado vem com um conjunto de permiss√µes padr√£o. Se voc√™ alguma vez desejou mudar esse conjunto de permiss√µes padr√£o, voc√™ pode fazer isso com o comando umask. Este comando utiliza o conjunto de 3 bits de permiss√µes num√©rico que estamos acostumados a ver.\nAo criar um arquivo no Linux, ele herda um conjunto de permiss√µes padr√£o. Esse comportamento √© controlado pelo comando umask, que define quais permiss√µes ser√£o removidas dos valores padr√£o ao criar novos arquivos e diret√≥rios.\nO umask utiliza um n√∫mero de 3 d√≠gitos octais, onde cada d√≠gito representa permiss√µes para:\n\nUsu√°rio (owner).\nGrupo (group).\nOutros (others).\n\nEsses valores determinam quais permiss√µes ser√£o subtra√≠das do conjunto padr√£o. Por exemplo, ao usar:\n$ umask 021\nNo exemplo acima, estamos afirmando que queremos que as permiss√µes padr√£o de novos arquivos permitam que os usu√°rios acessem tudo, mas para grupos queremos tirar a permiss√£o de grava√ß√£o e para outros queremos tirar a permiss√£o de execut√°vel. O umask padr√£o na maioria das distribui√ß√µes √© 022, significando acesso de todos os usu√°rios, mas nenhum acesso de grava√ß√£o para o grupo e outros usu√°rios. Quando voc√™ executa o comando umask, ele dar√° esse conjunto padr√£o de permiss√µes em qualquer arquivo novo que voc√™ fizer. No entanto, se voc√™ quiser que ele persista, voc√™ ter√° que modificar seu arquivo de inicializa√ß√£o (.profile).\nPara que o valor do umask seja aplicado sempre, adicione-o ao arquivo de inicializa√ß√£o do shell, como ~/.profile ou ~/.bashrc:",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Umask"
    ]
  },
  {
    "objectID": "conteudos/permissoes/5 - Setuid.html",
    "href": "conteudos/permissoes/5 - Setuid.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Existem muitos casos em que usu√°rios normais precisam de acesso avan√ßado para executar determinadas tarefas. O administrador do sistema n√£o pode estar sempre dispon√≠vel para digitar a senha de root toda vez que um usu√°rio necessite de acesso a um arquivo protegido, ent√£o h√° bits de permiss√£o de arquivos especiais para permitir esse comportamento. O Set User ID (SUID) permite a um usu√°rio executar um programa como o propriet√°rio do arquivo do programa, em vez de como eles mesmos.\nVamos ver um exemplo:\nSuponha que eu queira alterar minha senha, simples, certo? Eu apenas uso o comando passwd:\nO que o comando de senha est√° fazendo? Est√° modificando alguns arquivos, mas o mais importante √© modificar o arquivo /etc/shadow. Vamos olhar para esse arquivo por um segundo:\nOh, espere um minuto! Esse arquivo √© propriedade de root? Como √© poss√≠vel que possamos modificar um arquivo propriedade de root?\nVamos olhar para outro conjunto de permiss√µes, essa vez do comando que executamos:\nVoc√™ notar√° um novo bit de permiss√£o aqui, o SUID (s). Quando um arquivo tem esse bit de permiss√£o setado, permite que os usu√°rios que executaram o programa obt√™m as permiss√µes do propriet√°rio do arquivo, bem como a permiss√£o de execu√ß√£o, no caso, root. Portanto, enquanto um usu√°rio est√° executando o comando de senha, eles est√£o executando como root.\n√â por isso que podemos acessar um arquivo protegido como /etc/shadow quando executamos o comando de senha. Se voc√™ removesse esse bit, voc√™ veria que n√£o seria poss√≠vel modificar o arquivo /etc/shadow e, portanto, alterar sua senha.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Setuid"
    ]
  },
  {
    "objectID": "conteudos/permissoes/5 - Setuid.html#modificando-suid",
    "href": "conteudos/permissoes/5 - Setuid.html#modificando-suid",
    "title": "linuxteclab",
    "section": "Modificando SUID",
    "text": "Modificando SUID\nJ√° que as permiss√µes regulares, h√° dois jeitos de modificar as permiss√µes SUID.\nModo simb√≥lico:\n$ sudo chmod u+s myfile\nModo num√©rico:\n$ sudo chmod 4755 myfile\nComo voc√™ pode ver, o SUID √© denotado por um 4 e prefixado ao conjunto de permiss√µes. Voc√™ pode ver o SUID denotado como um S mai√∫sculo, o que significa que ele ainda faz a mesma coisa, mas n√£o tem permiss√µes de execu√ß√£o.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Setuid"
    ]
  },
  {
    "objectID": "conteudos/permissoes/7 - ProcessPermissions.html",
    "href": "conteudos/permissoes/7 - ProcessPermissions.html",
    "title": "linuxteclab",
    "section": "",
    "text": "##Processos e Permiss√µes em Linux\nVamos abordar um pouco mais sobre permiss√µes de processos em Linux. Lembrando que quando voc√™ executa o comando passwd com o bit de permiss√£o SUID habilitado, o programa √© executado como root? Isso √© verdade, mas isso significa que, como voc√™ est√° temporariamente como root, voc√™ pode modificar as senhas de outros usu√°rios? N√£o, felizmente n√£o!\nEssa √© porque do muitos IDs de usu√°rio (UIDs) que o Linux implementa. Existem tr√™s UIDs associados a cada processo:\n\nQuando voc√™ inicia um processo, ele √© executado com as mesmas permiss√µes do usu√°rio ou grupo que o executou, isso √© conhecido como effective user ID. Este UID √© usado para conceder direitos de acesso a um processo. Ent√£o, naturalmente, se Bob executasse o comando touch, o processo seria executado como ele e quaisquer arquivos que ele criasse estariam sob sua propriedade.\nH√° outro UID, chamado de real user ID, este √© o ID do usu√°rio que iniciou o processo. Eles s√£o usados ‚Äã‚Äãpara rastrear quem √© o usu√°rio que iniciou o processo.\nUm √∫ltimo UID √© o saved user ID, isso permite que um processo alterne entre o effective e o real, vice-versa. Isso √© √∫til porque n√£o queremos que nosso processo seja executado com privil√©gios elevados o tempo todo, √© apenas uma boa pr√°tica usar privil√©gios especiais em momentos espec√≠ficos.\n\nAgora, vamos juntar essas pe√ßas todas juntas, olhando para o comando passwd novamente.\nQuando voc√™ executa o comando passwd, sua effective UID √© sua ID de usu√°rio, por exemplo, 500 por enquanto. No entanto, o comando passwd tem o bit de permiss√£o SUID habilitado, portanto, quando voc√™ o executa, sua effective UID √© agora 0 (a UID de root). Agora, esse programa pode acessar arquivos como root.\nImagine que voc√™ deseja modificar a senha da Sally, que tem uma UID de 600. Bem, voc√™ n√£o vai ter sorte, felizmente, o processo tamb√©m tem sua UID real nesse caso, 500. Ele sabe que sua UID √© 500 e, portanto, voc√™ n√£o pode modificar a senha da UID de 600. (Claro que isso √© sempre contornado se voc√™ for superusu√°rio em uma m√°quina e pode controlar e alterar tudo.)\nNa maioria do tempo, a UID real e a UID effective s√£o as mesmas, mas em casos como o comando passwd, elas mudar√£o.",
    "crumbs": [
      "Home",
      "üìÇ Permissoes",
      "‚úÖ Processpermissions"
    ]
  },
  {
    "objectID": "conteudos/manipulacao-de-usuario/5- Arquivo group.html",
    "href": "conteudos/manipulacao-de-usuario/5- Arquivo group.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Al√©m do arquivo /etc/password, outro elemento importante no gerenciamento de usu√°rios √© o arquivo /etc/group. Esse arquivo permite criar grupos com permiss√µes diferentes.\nVeremos um exemplo do conte√∫do desse arquivo com o comando cat:\n$ cat /etc/group\nroot:*:0:bruno\nAs colunas do arquivo /etc/group s√£o semelhantes √†s do /etc/password, com as seguintes caracter√≠sticas:\n\n1: Nome do Grupo - Nome do grupo criado.\n2: Senha do Grupo - Embora n√£o seja necess√°rio definir uma senha para o grupo, √© comum usar privil√©gios elevados, como o sudo, para gerenciar grupos. O valor padr√£o √© ‚Äú*‚Äù.\n3: ID do Grupo (GID) - Identificador √∫nico do grupo.\n4: Lista de usu√°rios - Voc√™ pode especificar manualmente usu√°rios que deseja incluir em um grupo espec√≠fico.",
    "crumbs": [
      "Home",
      "üìÇ Manipulacao De Usuario",
      "‚úÖ Arquivo Group"
    ]
  },
  {
    "objectID": "conteudos/manipulacao-de-usuario/2- root.html",
    "href": "conteudos/manipulacao-de-usuario/2- root.html",
    "title": "Arquivo /etc/sudoers",
    "section": "",
    "text": "J√° aprendemos como obter acesso como superusu√°rio usando o comando sudo. Outra forma de obter esse acesso √© com o comando su. Este comando substitui usu√°rios e abre uma shell raiz se n√£o houver usu√°rio especificado. Voc√™ pode us√°-lo para substituir qualquer usu√°rio desde que saiba a senha.\n$ su\nNo entanto, h√° algumas desvantagens em usar esse m√©todo: √© muito f√°cil cometer um erro cr√≠tico executando todos os comandos como raiz, todas as a√ß√µes s√£o realizadas como root, tornando dif√≠cil rastrear qual usu√°rio realizou uma opera√ß√£o espec√≠fica, etc. Em resumo, se voc√™ precisar executar comandos como superusu√°rio, basta usar sudo.\nAgora que sabemos quais comandos usar como superusu√°rio, a pergunta √©: Como voc√™ sabe quem tem acesso para fazer isso? O sistema n√£o permite que qualquer um execute comandos como superusu√°rio, ent√£o como saber?\nExiste um arquivo chamado /etc/sudoers que lista os usu√°rios que podem executar o comando sudo. Voc√™ pode editar esse arquivo com o comando visudo.\n\nArquivo /etc/sudoers\nEste arquivo √© onde o sistema armazena a lista de usu√°rios que podem executar comandos como superusu√°rio. Se voc√™ quiser adicionar ou remover usu√°rios da lista, use o comando visudo. Al√©m disso, o arquivo /etc/sudoers √© protegido por senha, garantindo que apenas usu√°rios autorizados possam realiz√°-las altera√ß√µes.\n\n\nArquivo visudo\nO comando visudo √© o executor de edi√ß√£o do arquivo /etc/sudoers. Ele abre o arquivo em modo de edi√ß√£o segura, permitindo que voc√™ adicione ou remova usu√°rios da lista de usu√°rios autorizados. Al√©m disso, o comando visudo tamb√©m verifica se as altera√ß√µes feitas s√£o corretas antes de permitir que elas sejam aplicadas ao sistema.\n\n\nExemplos\n\nsudo -l: Mostra a lista de comandos que voc√™ como superusu√°rio pode executar.\nvisudo: Abre o arquivo /etc/sudoers em modo de edi√ß√£o segura.\nsudo nano /etc/sudoers: Abre o arquivo /etc/sudoers para editar com o nano.",
    "crumbs": [
      "Home",
      "üìÇ Manipulacao De Usuario",
      "‚úÖ Root"
    ]
  },
  {
    "objectID": "conteudos/manipulacao-de-usuario/3- Arquivo passwd.html",
    "href": "conteudos/manipulacao-de-usuario/3- Arquivo passwd.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Lembre-se de que os nomes de usu√°rio n√£o s√£o, em realidade, identificadores de usu√°rios. O sistema utiliza um IDENTIFIER DE USU√ÅRIO (UID) para identificar um usu√°rio. Para descobrir quais usu√°rios est√£o mapeados para que identificador, veja o arquivo /etc/passwd.\n$ cat /etc/passwd```\n\nEsse arquivo lista usu√°rios e informa√ß√µes detalhadas sobre eles. Por exemplo, a primeira linha desse arquivo provavelmente se assemelha a essa:\n\n```bash\nroot:x:0:0:root:/root:/bin/bash\nCada linha exibe informa√ß√µes de usu√°rio para um usu√°rio, sendo que o usu√°rio root √© comummente apresentado como a primeira linha. Existem muitos campos separados por dois pontos que fornecem informa√ß√µes adicionais sobre o usu√°rio, veja que no caso s√£o 7 campos, vamos analis√°-los:\n\n1: Nome de usu√°rio.\n2: Senha do usu√°rio - embora a senha n√£o esteja armazenada neste arquivo, est√° geralmente armazenada no arquivo /etc/shadow. Discutiremos mais sobre /etc/shadow na pr√≥xima aula, mas por agora, saiba que cont√©m senhas de usu√°rio criptografadas. Voc√™ pode ver muitos s√≠mbolos diferentes nesse campo, se vir um ‚Äúx‚Äù, isso significa que a senha est√° armazenada no arquivo /etc/shadow, um ‚Äú*‚Äù indica que o usu√°rio n√£o tem acesso ao login e um campo em branco indica que o usu√°rio n√£o tem senha.\n3: ID do usu√°rio - como voc√™ pode ver, o usu√°rio root tem o ID de usu√°rio 0.\n4: ID do grupo.\n5: Campo GECOS - este √© utilizado para deixar coment√°rios geralmente sobre o usu√°rio ou conta, como nome real ou n√∫mero de telefone, e √© delimitado por v√≠rgulas.\n6: Diret√≥rio de home do usu√°rio.\n\n7: Shell do usu√°rio - provavelmente ver√° muitos usu√°rios utilizando o shell padr√£o bash.\n\nNormalmente, na p√°gina de configura√ß√£o de usu√°rio, voc√™ espera ver apenas usu√°rios humanos. No entanto, voc√™ notar√° que /etc/passwd cont√©m outros usu√°rios. Lembre-se de que os usu√°rios s√£o, na realidade, apenas no sistema para executar processos com permiss√µes diferentes. √Äs vezes, queremos executar processos com permiss√µes pr√©-definidas. Por exemplo, o usu√°rio daemon √© utilizado para processos daemon.\nAl√©m disso, √© importante notar que voc√™ pode editar o arquivo /etc/passwd manualmente se quiser adicionar usu√°rios e modificar informa√ß√µes com o tool vipw, no entanto, coisas como essas s√£o melhor deixadas para tools, como useradd e userdel.",
    "crumbs": [
      "Home",
      "üìÇ Manipulacao De Usuario",
      "‚úÖ Arquivo Passwd"
    ]
  },
  {
    "objectID": "conteudos/processos/10 - _proc filesystem.html",
    "href": "conteudos/processos/10 - _proc filesystem.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Em Linux, tudo √© considerado um arquivo, inclusive informa√ß√µes de processos. A detalhada informa√ß√µes de processos s√£o armazenadas em um filesystem especial chamado /proc.\n$ ls /proc\nVoc√™ deve ver v√°rios valores aqui. Existem sub-diret√≥rios para cada PID. Se voc√™ olhasse um PID no output do comando ps, poderia encontr√°-lo no diret√≥rio /proc.\nV√° em frente e entre em um dos processos e observe o arquivo:\n$ cat /proc/12345/status\nVoc√™ deve ver informa√ß√µes de estado do processo e informa√ß√µes mais detalhadas. O diret√≥rio /proc √© como o kernel v√™ o sistema, ent√£o h√° muito mais informa√ß√µes aqui do que voc√™ veria no comando ps.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Proc Filesystem"
    ]
  },
  {
    "objectID": "conteudos/processos/11 - Status de processos.html",
    "href": "conteudos/processos/11 - Status de processos.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Vamos dar outra olhada no comando ps aux:\n$ ps aux\nNa coluna STATE, voc√™ ver√° muitas combina√ß√µes de valores. Um processo no Linux pode estar em um n√∫mero de estados diferentes. Os c√≥digos de estado mais comuns que voc√™ ir√° encontrar est√£o descritos abaixo:\n\nR: O processo est√° em execu√ß√£o ou pronto para ser executado, apenas aguardando a libera√ß√£o do CPU.\nS: O processo est√° dormindo, aguardando a conclus√£o de um evento, como a entrada de dados na terminal.\nD: O processo est√° indiferente ao sinal, n√£o pode ser interrompido ou cancelado, normalmente porque est√° causando problemas e precisa ser reiniciado ou corrigido.\nZ: O processo zumbi, um processo que foi conclu√≠do, mas est√° aguardando pela coleta de status. Discutimos isso detalhadamente em aula anterior.\nT: O processo est√° parado, suspensamente ou interrompido.\n\nLembre-se de que entender o estado de um processo √© essencial para troubleshooting e gerenciamento de processos no Linux.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Status De Processos"
    ]
  },
  {
    "objectID": "conteudos/processos/8 - niceness.html",
    "href": "conteudos/processos/8 - niceness.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Quando executamos v√°rios softwares, como Chrome, Microsoft Word or Photoshop ao mesmo tempo, Pode parecer que o computador roda tudo ao mesmo tempo. No entanto, isso n√£o √© exatamente verdade. Os processos utilizam o processador para um pequeno per√≠odo de tempo chamado time slice. Em seguida, pausam por milissegundos e outro processo recebe um time slice. Por padr√£o, a gest√£o de processos ocorre em uma sequ√™ncia round-robin. Cada processo recebe um n√∫mero suficiente de time slices at√© ser conclu√≠do. O kernel √© respons√°vel por fazer as trocas entre os processos e faz um √≥timo trabalho nisso a maioria do tempo.\nOs processos n√£o podem decidir quando e por quanto tempo recebem tempo da CPU. Se todos os processos se comportassem normalmente, cada um (aproximadamente) receberia uma quantidade igual de tempo da CPU. No entanto, h√° uma maneira de influenciar o algoritmo de agendamento de processos do kernel com um valor de nice. A nice √© um nome um pouco estranho, mas o que significa √© que os processos t√™m um n√∫mero para determinar sua prioridade para a CPU. Um n√∫mero alto significa que o processo √© ‚Äúnice‚Äù e tem uma prioridade baixa para a CPU, enquanto um n√∫mero baixo ou negativo significa que o processo n√£o √© t√£o ‚Äúnice‚Äù e deseja obter tanto tempo da CPU quanto poss√≠vel.\n$ top\nVoc√™ pode ver uma coluna chamada ‚ÄúNI‚Äù agora, que √© o n√≠vel de nice de um processo. Para mudar o n√≠vel de nice, voc√™ pode usar os comandos nice e renice:\n$ nice -n 5 apt upgrade\nO comando nice √© usado para definir a prioridade para um processo novo. O comando renice √© usado para definir prioridade em um processo existente.\n$ renice 10 -p 3245",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Niceness"
    ]
  },
  {
    "objectID": "conteudos/processos/4 - Cria√ß√£o de processos.html",
    "href": "conteudos/processos/4 - Cria√ß√£o de processos.html",
    "title": "A√ß√£o",
    "section": "",
    "text": "Nesse pr√≥ximo passo, vamos explorar a cria√ß√£o de processos em profundidade. O conte√∫do destas li√ß√µes e da pr√≥xima s√£o meramente informativos, para que voc√™ possa entender como as coisas funcionam por baixo dos panos. √â livre para voltar a este material mais tarde, ap√≥s trabalhar com processos por um determinado tempo.\nCriando Processos\nQuando um novo processo √© criado, um processo existente basicamente clona a si mesmo utilizando chamadas de sistema chamadas fork. A chamada de sistema fork cria um processo filho quase id√™ntico, que recebe um novo ID de processo (PID) e o processo original se torna seu processo pai e tem algo chamado ID de processo pai (PPID). Em seguida, o processo filho pode continuar a usar o mesmo programa que seu processo pai estava usando anteriormente, ou mais frequentemente, usar a chamada de sistema execve para lan√ßar um programa novo. Essa chamada de sistema destr√≥i a gest√£o de mem√≥ria que o kernel criou para aquele processo e configura novas para o programa novo.\n\nA√ß√£o\nVeja isso em a√ß√£o:\n$ ps l\nA op√ß√£o l fornece uma ‚Äúvis√£o longa‚Äù ou mais detalhada dos processos em execu√ß√£o. Voc√™ ver√° uma coluna rotulada PPID, que √© o ID de pai. Agora, olhe para o seu terminal, voc√™ ver√° um processo rodando que √© o seu shell, ent√£o, em meu sistema, tenho um processo rodando bash. Agora, lembre-se quando voc√™ executou o comando ps l, voc√™ o executou a partir do processo que estava rodando bash. Agora, voc√™ ver√° que o PID do shell bash √© o PPID do comando ps l.\n\n\nA ‚ÄúM√£e‚Äù de todos os Processos\nSe todos os processos t√™m que ter um pai e s√£o apenas c√≥pias um do outro, haver√° uma ‚Äúm√£e‚Äù de todos os processos, certo? Sim, voc√™ est√° correto. Quando o sistema inicializa, o kernel cria um processo chamado init, que tem um PID de 1. O processo init n√£o pode ser interrompido a menos que o sistema feche. Ele √© executado com privil√©gios de root e executa muitos processos que mant√©m o sistema em execu√ß√£o.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Cria√ß√£o De Processos"
    ]
  },
  {
    "objectID": "conteudos/processos/7 - kill(Terminate).html",
    "href": "conteudos/processos/7 - kill(Terminate).html",
    "title": "Sinaliza√ß√£o e Processos",
    "section": "",
    "text": "Sinaliza√ß√£o e Processos\nVoc√™ pode enviar sinais que terminam processos, por exemplo, o comando kill. Veja como funciona:\n$ kill 12445\nO n√∫mero 12445 √© o PID do processo que voc√™ deseja matar. Por padr√£o, ele envia o sinal SIGTERM. O sinal SIGTERM √© enviado para um processo para solicitar sua t√©rmino permitindo que ele libere seus recursos de forma limpa e guarde seu estado.\nVoc√™ tamb√©m pode especificar um sinal com o comando kill:\n$ kill -9 12445\nIsso executar√° o sinal SIGKILL e matar√° o processo imediatamente.\n\n\nDiferen√ßa entre SIGHUP, SIGINT, SIGTERM, SIGKILL e SIGSTOP\nEsses sinais podem parecer muito semelhantes, mas tem suas diferen√ßas.\nSIGHUP: √â um sinal de ‚Äúhangup‚Äù, enviado para um processo quando o terminal de controle √© fechado. Por exemplo, se voc√™ fechasse uma janela de terminal que havia um processo rodando nele, voc√™ receberia um sinal SIGHUP. Nesse caso, voc√™ est√° sendo ‚Äúcolocado na espera‚Äù.\nSIGINT: √â um sinal de ‚Äúinterrupt‚Äù, portanto, voc√™ pode usar Ctrl+C e o sistema tentar√° matar o processo de forma graciosa.\nSIGTERM: Mata o processo, mas permite que ele fa√ßa alguns arranjos antes de parar. Isso √© √∫til porque os processos podem ter recursos que precisam ser liberados antes de serem encerrados.\nSIGKILL: Mata o processo! N√£o h√° nenhuma limpeza ou arranjo.\nSIGSTOP: Pare/suspende um processo.",
    "crumbs": [
      "Home",
      "üìÇ Processos",
      "‚úÖ Kill(Terminate)"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/7-head.html",
    "href": "conteudos/arte-do-texto/7-head.html",
    "title": "Usando o comando head",
    "section": "",
    "text": "Usando o comando head\nVamos imaginar que temos um arquivo muito extenso; na verdade, temos muitos arquivos longos para escolher.\nExperimente executar o comando\n$ cat /var/log/syslog\nVoc√™ ver√° v√°rias p√°ginas de texto. Mas e se eu quiser ver apenas as primeiras linhas desse arquivo? Podemos fazer isso com o comando head.\nPor padr√£o, o comando head mostra as primeiras 10 linhas de um arquivo. Portanto, ao executar:\n$ head /var/log/syslog\nVoc√™ ver√° essas linhas iniciais. Se desejar modificar a contagem de linhas para um n√∫mero espec√≠fico, como por exemplo, as primeiras 15 linhas, voc√™ pode usar a op√ß√£o -n.\nO comando ficaria assim:\n$ head -n 15 /var/log/syslog\nAqui, a flag -n indica o n√∫mero de linhas que voc√™ deseja visualizar.",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Head"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/9-grep.html",
    "href": "conteudos/arte-do-texto/9-grep.html",
    "title": "O comando grep: o seu melhor amigo no tratamento de texto",
    "section": "",
    "text": "O comando grep: o seu melhor amigo no tratamento de texto\nO grep √© provavelmente o comando de tratamento de texto mais utilizado. Permite que voc√™ procure em arquivos por caracteres que correspondam a um padr√£o espec√≠fico. Se voc√™ quisesse saber se um arquivo existe em um diret√≥rio espec√≠fico ou se um determinada string esta presente em um arquivo, voc√™ pode utilizar o grep!\nVamos usar o arquivo exemplo.txt como refer√™ncia:\n rato\n cachorro\n gato\n elefante\n pato\n$ grep rato exemplo.txt\nE voc√™ descobrir√° se o grep encontrou o termo ‚Äúrato‚Äù no arquivo exemplo.txt, pois ele mostrar√° a linha com a palavra!\nAl√©m disso, voc√™ tamb√©m pode procurar padr√µes que n√£o dependem da case (mai√∫sculas ou min√∫sculas) com a flag -i:\n$ grep -i patrimOnio pat_arquivo.txt\nPara tornar ainda mais flex√≠vel o grep, voc√™ pode combinar ele com outros comandos utilizando o operador |:\n$ env | grep -i User\nComo voc√™ pode ver, o grep √© muito vers√°til. Al√©m disso, voc√™ tamb√©m pode usar express√µes regulares no seu padr√£o:\n$ ls /diret√≥rio | grep -E '.txt$'\nIsso deve retornar todos os arquivos que terminam com ‚Äú.txt‚Äù no diret√≥rio especificado!",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Grep"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/6-cut.html",
    "href": "conteudos/arte-do-texto/6-cut.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Aprenderemos alguns comandos √∫teis que voc√™ pode usar para processar texto. Antes de come√ßarmos, vamos criar um arquivo com o qual trabalharemos. Copie e cole o seguinte comando, depois de fazer isso, adicione uma TAB entre cachorro e pregui√ßoso (pressione Ctrl-v + TAB, isso insere um caractere de tabula√ß√£o real).\n$ echo 'O Linux √© r√°pido; o Linux √© seguro' &gt; exemplo.txt\nO comando que aprenderemos √© o comando cut. Extrai partes de texto de um arquivo.\nPara extrair o conte√∫do por uma lista de caracteres:\n   $ cut -c 5 exemplo.txt\n¬†Isso mostra o quinto caractere em cada linha do arquivo. Neste caso √© ‚Äún‚Äù, observe que o espa√ßo tamb√©m conta como caractere.\nPara extrair o conte√∫do de um campo, precisaremos fazer uma pequena modifica√ß√£o. O sinalizador -f ou campo corta o texto com base nos campos; por padr√£o, ele usa TABs como delimitadores, portanto, tudo separado por uma TAB √© considerado um campo.\nVoc√™ pode combinar o sinalizador de campo com o sinalizador de delimitador para extrair o conte√∫do por um delimitador personalizado, assim o -d indica o delimitador que por padr√£o √© o TAB:\n$ cut -f 1 -d \";\" exemplo.txt\nVoc√™ pegar√° o primeiro campo -f 1, e usar√° como delimitador o caracter ‚Äú;‚Äù -d ‚Äú;‚Äù. Dever√° ver no terminal ‚ÄúO Linux √© r√°pido‚Äù.",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Cut"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/10-sort.html",
    "href": "conteudos/arte-do-texto/10-sort.html",
    "title": "Ordena√ß√£o de Textos com o Comando sort",
    "section": "",
    "text": "Ordena√ß√£o de Textos com o Comando sort\nO comando sort √© uma ferramenta √∫til para organizar linhas de texto de acordo com um crit√©rio predeterminado. Vamos ver exemplos de como us√°-lo para ordenar linhas de um arquivo de texto.\n\nExemplo 1: Ordena√ß√£o Alfab√©tica\nContinuemos com o arquivo exemplo.txt, que cont√©m os seguintes termos:\narq.txt\n rato\n cachorro\n gato\n elefante\n pato\nQuando executamos o comando sort sobre esse arquivo, obtemos o seguinte resultado:\n$ sort arq.txt\n cachorro\n elefante\n gato\n pato\n rato\nA ordena√ß√£o √© feita alfabeticamente, portanto, os termos come√ßam a aparecer na ordem correta.\n\n\nExemplo 2: Ordena√ß√£o em Ordem inversa\nMais um exemplo interessante √© a ordena√ß√£o em ordem inversa. Para isso, podemos usar a op√ß√£o -r do comando sort. Vou mostrar como:\n$ sort -r arq.txt\n rato\n pato\n gato\n elefante\n cachorro\nAgora, a ordena√ß√£o √© feita em ordem inversa, portanto, os termos aparecem na ordem oposta.",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Sort"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/1-stdout.html",
    "href": "conteudos/arte-do-texto/1-stdout.html",
    "title": "stdout (standard Out)",
    "section": "",
    "text": "stdout (standard Out)\nUm assunto bem interessante no mundo do terminal s√£o os fluxos de E/S (entrada/sa√≠da). Veja o comando abaixo.\n$ echo Hello World &gt; arq.txt\nO que aconteceu? Bem, verifique o diret√≥rio onde voc√™ executou esse comando e eis que voc√™ dever√° ver um arquivo chamado arq.txt, olhe dentro desse arquivo e dever√° ver o texto Hello World. Muitas coisas aconteceram em um comando, ent√£o vamos detalhar.\nA primeira parte desse comando √©:\n$ echo Hello World\nSabemos que o comando echo imprime Hello World na tela, mas como? Os processos usam fluxos de E/S para receber entrada e retornar sa√≠da. Por padr√£o, o comando echo pega a entrada (entrada padr√£o ou stdin) do teclado e retorna a sa√≠da (sa√≠da padr√£o ou stdout) para a tela. √â por isso que quando voc√™ digita echo Hello World em seu shell, voc√™ obt√©m Hello World na tela. No entanto, o redirecionamento de E/S nos permite alterar esse comportamento padr√£o, proporcionando maior flexibilidade de arquivos.\nVamos prosseguir para a pr√≥xima parte do comando:\n&gt;\nO &gt; √© um operador de redirecionamento que nos permite alterar para onde vai a sa√≠da padr√£o (stdout). Ele nos permite enviar a sa√≠da de echo Hello World para um arquivo em vez de para a tela. Se o arquivo ainda n√£o existir, ele ser√° criado para n√≥s. No entanto, se existir, ele ser√° sobrescrito. E √© basicamente assim que funciona o redirecionamento stdout!\nBem, digamos que eu n√£o queira sobrescrever meu arq.txt, felizmente tamb√©m existe um operador de redirecionamento para isso, &gt;&gt; ou seja voc√™ far√° um append no arquivo.\n$ echo Hello World &gt;&gt; saida.txt",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Stdout"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/12-tr.html",
    "href": "conteudos/arte-do-texto/12-tr.html",
    "title": "linuxteclab",
    "section": "",
    "text": "Comandos de Tradu√ß√£o\nO comando tr permite que voc√™ traduza um conjunto de caracteres em outro conjunto de caracteres. Vamos tentar um exemplo de traduzir todos os caracteres minusculos em mai√∫sculos.\nPor exemplo, se voc√™ digitar $ tr a-z A-Z e em seguida pressionar Enter, obter√° o seguinte resultado:\n$ echo \"linux\" | tr a-z A-Z\nLINUX\nNesse exemplo, podemos ver que todos os caracteres minusculados (a-z) foram convertidos para mai√∫sculos (A-Z).\nEsse comando √© √∫til em diversas situa√ß√µes, tais como quando voc√™ precisa corrigir arquivos de texto com erros de formata√ß√£o, alterar nomes de times de futebol (por exemplo, transformar ‚ÄúBar√ßa‚Äù em ‚ÄúBAR√áA‚Äù) ou qualquer necessidade para altera√ß√£o de caracter.",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Tr"
    ]
  },
  {
    "objectID": "conteudos/arte-do-texto/3-stderr.html",
    "href": "conteudos/arte-do-texto/3-stderr.html",
    "title": "stderr",
    "section": "",
    "text": "stderr\nVamos tentar algo um pouco diferente agora, vamos tentar listar o conte√∫do de um diret√≥rio que n√£o existe no seu sistema e redirecionar a sa√≠da para o arquivo arq.txt novamente.\n$ ls /tmp/naoexiste &gt; arq.txt\nOk, mas reparou que foi exibido na tela:\nls: n√£o foi poss√≠vel acessar '/tmp/naoexiste': Arquivo ou diret√≥rio inexistente\nAgora voc√™ provavelmente est√° pensando: aquela mensagem n√£o deveria ter sido enviada para o arquivo? Na verdade, h√° outro fluxo de E/S em jogo aqui chamado erro padr√£o (stderr). Por padr√£o, o stderr tamb√©m envia sua sa√≠da para a tela, mas √© um fluxo completamente diferente do stdout.\nEnt√£o voc√™ precisar√° redirecionar sua sa√≠da de uma maneira diferente. Teremos que usar descritores de arquivo. Um descritor de arquivo √© um n√∫mero n√£o negativo usado para acessar um arquivo ou fluxo. Iremos aprofundar isso mais tarde, mas por enquanto sabemos que o descritor de arquivo para stdin, stdout e stderr √© 0, 1 e 2 respectivamente. Ent√£o agora, se quisermos redirecionar nosso stderr para o arquivo, podemos fazer isso:\n$ ls /tmp/naoexiste 2&gt; arq.txt\nAgora, e se eu quisesse ver stderr e stdout no arquivo arq.txt? Tamb√©m √© poss√≠vel fazer isso com descritores de arquivo:\n$ ls /tmp/naoexiste &gt; arq.txt 2&gt;&1\nIsso envia os resultados de ls /tmp/naoexiste para o arquivo arq.txt e ent√£o redireciona o stderr para o stdout via 2&gt;&1. A ordem das opera√ß√µes aqui √© importante, 2&gt;&1 envia stderr para qualquer que seja o stdout que esteja apontando. Nesse caso, stdout est√° apontando para um arquivo, ent√£o 2&gt;&1 tamb√©m envia stderr para um arquivo. Portanto, se voc√™ abrir o arquivo arq.txt, ver√° stderr e stdout. No nosso caso, o comando acima gera apenas stderr.\nExiste uma maneira mais curta de redirecionar stdout e stderr para um arquivo, e voc√™ ver√° ele bastante por a√≠:\n$ ls /tmp/naoexiste &&gt; arq.txt\nAgora, e se eu n√£o quiser nada desse lixo e quiser se livrar completamente das mensagens stderr? Bem, voc√™ tamb√©m pode redirecionar a sa√≠da para uma chamada de arquivo especial /dev/null e ela descartar√° qualquer entrada.\n$ ls /tmp/naoexiste 2&gt; /dev/null",
    "crumbs": [
      "Home",
      "üìÇ Arte Do Texto",
      "‚úÖ Stderr"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/13-man.html",
    "href": "conteudos/linha-de-comando/13-man.html",
    "title": "man",
    "section": "",
    "text": "man\nUm comando que pode te salvar em muitos momentos √© o man. √â uma interface para manuais, com ele voc√™ pode buscar ajuda sem precisar do chatGPT :) .\nO man √© organizado por se√ß√µes, cada se√ß√£o √© representada por um n√∫mero, veja a tabela abaixo que descreve as se√ß√µes. Mas basicamente, os comandos s√£o da se√ß√£o 1.\nPodemos fazer uma pesquisa sobre o comando ls.\n$ man ls\nE para fazer um pesquisa sobre manuais que contenham a palavra passwd:\n$ man -k passwd",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Man"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/9-cp.html",
    "href": "conteudos/linha-de-comando/9-cp.html",
    "title": "cp",
    "section": "",
    "text": "cp\nVamos come√ßar a fazer algumas c√≥pias desses arquivos. Assim como copiar e colar arquivos em outros sistemas operacionais, o shell nos oferece uma maneira ainda mais simples de fazer isso, e nem precisamos do mouse para isso :).\n$ cp meuarquivo /home/bruno/\nmeuqrquivo √© o arquivo que voc√™ deseja copiar e /home/bruno √© para onde voc√™ est√° copiando o arquivo. Voc√™ pode copiar v√°rios arquivos e diret√≥rios, bem como usar curingas. Um curinga √© um caractere que pode substituir uma sele√ß√£o baseada em padr√£o, proporcionando mais flexibilidade. Voc√™ pode usar curingas em v√°rios comandos para obter mais flexibilidade.\n\n* o curinga dos curingas, √© usado para representar todos os caracteres √∫nicos ou qualquer string.\n? usado para representar um caractere.\n[] usado para representar qualquer caractere entre colchetes.\n\n$ cp *.jpg /home/bruno/Imagens\nIsso copiar√° todos os arquivos com extens√£o .jpg em seu diret√≥rio atual para o diret√≥rio Imagens. Uma op√ß√£o √∫til √©¬† a¬† -r, isso copiar√° recursivamente os arquivos e diret√≥rios dentro de um diret√≥rio. Tente fazer um cp em um diret√≥rio que cont√©m alguns arquivos no diret√≥rio Documentos. N√£o funcionou, n√£o √©? Bem, isso √© porque voc√™ tamb√©m precisar√° copiar os arquivos e diret√≥rios internos com o comando -r.\nUma coisa a observar: se voc√™ copiar um arquivo para um diret√≥rio que tenha o mesmo nome de arquivo, o arquivo ser√° substitu√≠do por tudo o que voc√™ est√° copiando. Isso n√£o √© legal se voc√™ tiver um arquivo que n√£o deseja que seja substitu√≠do acidentalmente, pior ainda se n√£o tiver backup. Voc√™ pode usar a op√ß√£o -i (interativo) para avisar antes de substituir um arquivo.\n$ cp -i meuarquivo /home/bruno/",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Cp"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/7-less.html",
    "href": "conteudos/linha-de-comando/7-less.html",
    "title": "less",
    "section": "",
    "text": "less\nSe voc√™ estiver visualizando arquivos de texto maiores que uma sa√≠da simples, use o comando less. (existe um comando chamado more que faz algo semelhante, mas nesse caso menos √© mais :)) O texto √© exibido em forma de p√°gina, para que voc√™ possa navegar por um arquivo de texto p√°gina por p√°gina. V√° em frente e observe o conte√∫do de um arquivo com menos. Quando estiver no comando less, voc√™ poder√° usar outros comandos de teclado para navegar no arquivo.\n$ less /tmp/arquivo\nUse os seguintes comandos para navegar usando less:\nq - Usado para sair do less e voltar para o seu shell.\nPage up, Page down, Up e Down - Navegue usando as teclas de seta e de p√°gina.\ng - Vai para o in√≠cio do arquivo de texto.\nG - Vai para o final do arquivo de texto.\n/search - Voc√™ pode pesquisar um texto espec√≠fico dentro do documento de texto. Prefaciando as palavras que voc√™ deseja pesquisar com /\nh - Se voc√™ precisar de uma ajudinha sobre como usar o less, use a ajuda.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Less"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/14-find.html",
    "href": "conteudos/linha-de-comando/14-find.html",
    "title": "find",
    "section": "",
    "text": "find\nCom todos esses arquivos que temos no sistema pode ser um pouco desafiador tentar encontrar um arquivo espec√≠fico. Para isso podemos usar o find.\n$ find /home -name livro.pdf\nNo uso b√°sico do comando find, voc√™ ter√° que especificar o diret√≥rio que ir√° pesquisar e o que est√° procurando, neste caso estamos tentando encontrar um arquivo com o nome de livro.pdf.\nVoc√™ pode especificar que tipo de arquivo est√° tentando encontrar, como um diret√≥rio.\n$ find /home -type d -name documentos\nJunto ao -type a op√ß√£o d se refere a diret√≥rio, a op√ß√£o f se refere a um arquivo comum.\nUma coisa legal a se notar √© que find n√£o para no diret√≥rio que voc√™ est√° pesquisando, ele tamb√©m procurar√° dentro de quaisquer subdiret√≥rios que esse diret√≥rio possa ter.\nE caso voc√™ queira que a pesquisa seja case insensitive, use -iname.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Find"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/3-ls.html",
    "href": "conteudos/linha-de-comando/3-ls.html",
    "title": "ls",
    "section": "",
    "text": "ls\nAgora que sabemos como nos movimentar pelo sistema, como podemos descobrir o que est√° dispon√≠vel para n√≥s? Neste momento √© como se estiv√©ssemos nos movendo no escuro. Bem, n√£o mais, podemos usar o maravilhoso comando ls para listar o conte√∫do do diret√≥rio. O comando ls listar√° diret√≥rios e arquivos no diret√≥rio atual por padr√£o, mas voc√™ pode especificar qual caminho deseja listar os diret√≥rios.\n$ ls -l /home/bruno\ntotal 36\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29 '√Årea de trabalho'\ndrwxr-xr-x 3 caires caires 4096 jun 29 14:26  book\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  Documentos\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  Downloads\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  Imagens\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  Modelos\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  M√∫sica\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  P√∫blico\ndrwxr-xr-x 2 caires caires 4096 jun 29 14:29  V√≠deos\n¬†\nls √© uma ferramenta bastante √∫til, mas tamb√©m mostra informa√ß√µes detalhadas sobre os arquivos e diret√≥rios que voc√™ est√° visualizando.\n$ ls -la\ntotal 84\ndrwxr-xr-x 15 caires caires 4096 jun 29 14:16  .\ndrwxr-xr-x  4 root   root   4096 jun 29 03:14  ..\ndrwxr-xr-x  2 caires caires 4096 jun 29 14:29 '√Årea de trabalho'\n-rw-------  1 caires caires   35 jun 29 15:56  .bash_history\n-rw-r--r--  1 caires caires  220 jun 29 03:14  .bash_logout\n-rw-r--r--  1 caires caires 3391 jun 29 03:14  .bashrc\n-rw-r--r--  1 caires caires 3526 jun 29 03:14  .bashrc.original\ndrwxr-xr-x  3 caires caires 4096 jun 29 14:26  book\ndrwx------  9 caires caires 4096 jun 29 15:56  .cache\ndrwx------  9 caires caires 4096 jun 29 15:56  .config\ndrwxr-xr-x  2 caires caires 4096 jun 29 14:29  Documentos\nObserve tamb√©m que nem todos os arquivos em um diret√≥rio estar√£o vis√≠veis. Nomes de arquivos que come√ßam com . est√£o ocultos, voc√™ pode visualiz√°-los com o comando ls e passar a op√ß√£o -a para ele (amostra todos arquivos).\nH√° tamb√©m mais uma op√ß√£o ls √∫til, -l para long, que mostra uma lista detalhada de arquivos em um formato longo. Isso mostrar√° informa√ß√µes detalhadas, come√ßando pela esquerda: permiss√µes de arquivo, n√∫mero de links, nome do propriet√°rio, grupo de propriet√°rios, tamanho do arquivo, carimbo de data/hora da √∫ltima modifica√ß√£o e nome do arquivo/diret√≥rio.\nOs comandos t√™m op√ß√µes (ou argumentos, como voc√™ quiser cham√°-los) para adicionar mais funcionalidades. Veja como adicionamos -a e -l, bem, voc√™ pode adicionar os dois junto com -la. A ordem dos argumentos determina a ordem em que eles entram, na maioria das vezes isso realmente n√£o importa, ent√£o voc√™ tamb√©m pode fazer ls -al e ainda assim funcionaria.",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Ls"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/10-mv.html",
    "href": "conteudos/linha-de-comando/10-mv.html",
    "title": "mv",
    "section": "",
    "text": "mv\nUsado para mover arquivos e tamb√©m renome√°-los. Bastante semelhante ao comando cp em termos de op√ß√µes, voc√™ ver√° que na realidade muito comandos tem op√ß√£o semelhantes.\nVoc√™ pode renomear arquivos assim:\n$ mv arquivoantigo arquivonovo\nOu voc√™ pode mover um arquivo para um diret√≥rio diferente:\n$ mv arquivo /home/bruno/Documentos\nE mova mais de um arquivo:\n$ mv aruivo1 arquivo2 /tmp/nova\nRenomear diret√≥rios segue a mesma l√≥gica.\n$ mv dir1 dir2\nAssim como o cp, se voc√™ mover um arquivo ou diret√≥rio, ele substituir√° qualquer coisa no mesmo diret√≥rio. Portanto, voc√™ pode usar a op√ß√£o -i para avisar antes de substituir qualquer coisa.\n$ mv -i dir1 dir2\nDigamos que voc√™ queira mover um arquivo para substituir outro. Voc√™ tamb√©m pode fazer um backup desse arquivo e ele apenas renomear√° a vers√£o antiga com ~.\n$ mv -b dir1 dir2",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Mv"
    ]
  },
  {
    "objectID": "conteudos/linha-de-comando/2-cd.html",
    "href": "conteudos/linha-de-comando/2-cd.html",
    "title": "cd",
    "section": "",
    "text": "cd\nAgora que voc√™ sabe onde est√°, vamos nos movimentar um pouco no sistema de arquivos. Existem duas maneiras diferentes de especificar um caminho, tamb√©m conhecidos com PATH, como caminhos absolutos e relativos.\n\nCaminho absoluto: este √© o caminho do diret√≥rio raiz. A raiz √© o chefe. O diret√≥rio raiz √© comumente mostrado como uma barra. Cada vez que seu caminho come√ßa com / significa que voc√™ est√° iniciando no diret√≥rio raiz. Por exemplo, /home/bruno/Desktop.\nCaminho relativo: Este √© o caminho de onde voc√™ est√° atualmente no sistema de arquivos. Se eu estivesse no local /home/pete/Documents e quisesse chegar a um diret√≥rio dentro de Documentos chamado impostos, n√£o preciso especificar o caminho completo da raiz como /home/bruno/Documentos/impostos, posso simplesmente ir para impostos/ em vez disso.\n\nAgora que voc√™ sabe como funcionam os caminhos, s√≥ precisamos de algo que nos ajude a mudar para o diret√≥rio que desejamos. Felizmente, temos cd ou ‚Äúchange directory‚Äù para fazer isso.\n$ cd /home/bruno/backup\nAqui me movi para dentro do diret√≥rio /home/bruno/backup.\nAgora estando dentro desse diret√≥rio, tenho ali uma outra pasta chamada isos, posso navegar at√© ela com\n$ cd iso\nPode ser muito cansativo navegar por caminhos absolutos e relativos o tempo todo, felizmente existem alguns atalhos para ajud√°-lo.\n\n. (diret√≥rio atual). Este √© o diret√≥rio em que voc√™ est√° atualmente.\n‚Ä¶ (diret√≥rio pai). Leva voc√™ ao diret√≥rio acima do seu atual.\n~ (diret√≥rio inicial). Este diret√≥rio √© padronizado como seu ‚Äúdiret√≥rio inicial‚Äù. Como /home/pete.\n- (diret√≥rio anterior). Isso o levar√° ao diret√≥rio anterior em que voc√™ estava.\n\n$cd.\n\n$cd..\n\n$cd~\n\n$cd-",
    "crumbs": [
      "Home",
      "üìÇ Linha De Comando",
      "‚úÖ Cd"
    ]
  },
  {
    "objectID": "conteudos/pacotes/5 - RPM e dpkg.html",
    "href": "conteudos/pacotes/5 - RPM e dpkg.html",
    "title": "rpm e dpkg",
    "section": "",
    "text": "Pense assim, o .exe √© um arquivo execut√°vel √∫nico, assim como .deb e .rpm. Voc√™ provavelmente n√£o ver√° esses arquivos se usar reposit√≥rios de pacotes, mas se baixar pacotes diretamente, provavelmente ter√° que lidar com esses formatos. √â claro que eles s√£o exclusivos √†s suas distribui√ß√µes, .deb para Debian-based e .rpm para Red Hat-based.\nPara instalar esses pacotes diretos, voc√™ pode usar os comandos do gerenciamento de pacotes: rpm e dpkg. Esse s√£o os ferramentas utilizadas para instalar arquivos de pacotes, no entanto, n√£o instalam depend√™ncias de pacotes, ent√£o, se o seu pacote tiver 10 depend√™ncias, voc√™ precisaria instalar pacotes separadamente e, em seguida, suas depend√™ncias e assim por diante. Como voc√™ pode ver, isso foi um dos motivos que levaram ao surgimento dos sistemas de gerenciamento com apt.\nLembre-se de que haver√° in√∫meras vezes em que precisar√° instalar, consultar ou verificar um pacote com uma dessas ferramentas, ent√£o, lembre sempre esses comandos.\n\n\n\n\nDebian:\n$ dpkg -i some_deb_package.deb\n$ dpkg -r some_deb_package.deb\nNo Debian, -i significa install (instalar) e -r significa remove (remover).\nRPM:\n$ rpm -i some_rpm_package.rpm\n$ rpm -e some_rpm_package.rpm\nNo RPM, -i significa install (instalar) e -e significa erase (remover).\n\n\n\nDebian:\n$ dpkg -l\n-l significa list (lista).\nRPM:\n$ rpm -qa\n-q significa query (consulta) e a significa all (todos).",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Rpm E Dpkg"
    ]
  },
  {
    "objectID": "conteudos/pacotes/5 - RPM e dpkg.html#install-consulta-e-remo√ß√£o-de-pacotes",
    "href": "conteudos/pacotes/5 - RPM e dpkg.html#install-consulta-e-remo√ß√£o-de-pacotes",
    "title": "rpm e dpkg",
    "section": "",
    "text": "Debian:\n$ dpkg -i some_deb_package.deb\n$ dpkg -r some_deb_package.deb\nNo Debian, -i significa install (instalar) e -r significa remove (remover).\nRPM:\n$ rpm -i some_rpm_package.rpm\n$ rpm -e some_rpm_package.rpm\nNo RPM, -i significa install (instalar) e -e significa erase (remover).\n\n\n\nDebian:\n$ dpkg -l\n-l significa list (lista).\nRPM:\n$ rpm -qa\n-q significa query (consulta) e a significa all (todos).",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Rpm E Dpkg"
    ]
  },
  {
    "objectID": "conteudos/pacotes/3 - Arquivos Tar e Zip.html",
    "href": "conteudos/pacotes/3 - Arquivos Tar e Zip.html",
    "title": "Arquivos e Compress√£o no Linux",
    "section": "",
    "text": "Aprenda a gerenciar arquivos compactados no Linux antes de instalar pacotes de diferentes gerenciadores. Voc√™ provavelmente j√° conhece o conceito de arquivo ZIP ou RAR, que √© uma cole√ß√£o de arquivos compactados em um √∫nico arquivo, √© bem comum no mundo do Windows.\n\n\nO gzip √© um programa comum em Linux que compreende arquivo em formato .gz. Para comprimir um arquivo:\n$ gzip meuarquivo.txt\nPara descomprimir:\n$ gunzip meuarquivo.txt.gz\n\n\n\nInfelizmente, o gzip n√£o √© capaz de adicionar m√∫ltiplos arquivos em um arquivo ZIP. Felizmente, o programa tar (short for Tape ARchiver) permite fazer isso. Quando voc√™ cria um arquivo ZIP com tar, ele ter√° um prefixo .tar.\nExemplo:\n$ tar cvf meuarquivo.tar arquivo1.txt arquivo2.txt\nOp√ß√µes:\n\nc: criar um novo arquivo\nv: ser verboso e mostrar o que est√° fazendo\nf: fornece o nome do arquivo ZIP\n\n\n\n\nPara extrair os conte√∫do de um arquivo ZIP, use:\n$ tar xvf meuarquivo.tar\nOp√ß√µes:\n\nx: extrair os conte√∫dos do arquivo ZIP\nv: ser verboso e mostrar o que est√° fazendo\nf: fornece o nome do arquivo ZIP\n\n\n\n\nMuitas vezes, voc√™ encontrar√° um arquivo ZIP que foi compresso, como meuarquivo.tar.gz. Basta descomprimir com gunzip e, em seguida, extrair os conte√∫dos do arquivo ZIP com tar.\nExemplo:\n$ gunzip meuarquivo.tar.gz\n$ tar xvf meuarquivo.tar\nAlternativamente, voc√™ pode usar a op√ß√£o z com tar, que ir√° usar o gzip ou gunzip automaticamente.\nCriar um arquivo ZIP compresso:\n$ tar czf meuarquivo.tar.gz meuarquivo1.txt meuarquivo2.txt\nDescompressizar e extrair:\n$ tar xzf meuarquivo.tar.gz\n\n\n\nDurante seu caminho em Linux, voc√™ encontrar√° outras ferramentas de compress√£o e arquivamento, como bzip2, compress, zip e unzip. Lembre-se de que cada ferramenta tem suas pr√≥prias op√ß√µes e comandos.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Arquivos Tar E Zip"
    ]
  },
  {
    "objectID": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#compress√£o-com-gzip",
    "href": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#compress√£o-com-gzip",
    "title": "Arquivos e Compress√£o no Linux",
    "section": "",
    "text": "O gzip √© um programa comum em Linux que compreende arquivo em formato .gz. Para comprimir um arquivo:\n$ gzip meuarquivo.txt\nPara descomprimir:\n$ gunzip meuarquivo.txt.gz",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Arquivos Tar E Zip"
    ]
  },
  {
    "objectID": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#criar-arquivos-zip-com-tar",
    "href": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#criar-arquivos-zip-com-tar",
    "title": "Arquivos e Compress√£o no Linux",
    "section": "",
    "text": "Infelizmente, o gzip n√£o √© capaz de adicionar m√∫ltiplos arquivos em um arquivo ZIP. Felizmente, o programa tar (short for Tape ARchiver) permite fazer isso. Quando voc√™ cria um arquivo ZIP com tar, ele ter√° um prefixo .tar.\nExemplo:\n$ tar cvf meuarquivo.tar arquivo1.txt arquivo2.txt\nOp√ß√µes:\n\nc: criar um novo arquivo\nv: ser verboso e mostrar o que est√° fazendo\nf: fornece o nome do arquivo ZIP",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Arquivos Tar E Zip"
    ]
  },
  {
    "objectID": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#extrair-arquivos-zip-com-tar",
    "href": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#extrair-arquivos-zip-com-tar",
    "title": "Arquivos e Compress√£o no Linux",
    "section": "",
    "text": "Para extrair os conte√∫do de um arquivo ZIP, use:\n$ tar xvf meuarquivo.tar\nOp√ß√µes:\n\nx: extrair os conte√∫dos do arquivo ZIP\nv: ser verboso e mostrar o que est√° fazendo\nf: fornece o nome do arquivo ZIP",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Arquivos Tar E Zip"
    ]
  },
  {
    "objectID": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#compress√£o-e-descompress√£o-com-tar-e-gzip",
    "href": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#compress√£o-e-descompress√£o-com-tar-e-gzip",
    "title": "Arquivos e Compress√£o no Linux",
    "section": "",
    "text": "Muitas vezes, voc√™ encontrar√° um arquivo ZIP que foi compresso, como meuarquivo.tar.gz. Basta descomprimir com gunzip e, em seguida, extrair os conte√∫dos do arquivo ZIP com tar.\nExemplo:\n$ gunzip meuarquivo.tar.gz\n$ tar xvf meuarquivo.tar\nAlternativamente, voc√™ pode usar a op√ß√£o z com tar, que ir√° usar o gzip ou gunzip automaticamente.\nCriar um arquivo ZIP compresso:\n$ tar czf meuarquivo.tar.gz meuarquivo1.txt meuarquivo2.txt\nDescompressizar e extrair:\n$ tar xzf meuarquivo.tar.gz",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Arquivos Tar E Zip"
    ]
  },
  {
    "objectID": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#outras-ferramentas",
    "href": "conteudos/pacotes/3 - Arquivos Tar e Zip.html#outras-ferramentas",
    "title": "Arquivos e Compress√£o no Linux",
    "section": "",
    "text": "Durante seu caminho em Linux, voc√™ encontrar√° outras ferramentas de compress√£o e arquivamento, como bzip2, compress, zip e unzip. Lembre-se de que cada ferramenta tem suas pr√≥prias op√ß√µes e comandos.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Arquivos Tar E Zip"
    ]
  },
  {
    "objectID": "conteudos/pacotes/2 - Reposit√≥rios.html",
    "href": "conteudos/pacotes/2 - Reposit√≥rios.html",
    "title": "Compreendendo os Reposit√≥rios de Pacotes",
    "section": "",
    "text": "Compreendendo os Reposit√≥rios de Pacotes\nVoc√™ provavelmente j√° se perguntou como os pacotes que s√£o subidos na internet acabam chegando nos seus computadores? Voc√™ vai a p√°gina de download de cada pacote que deseja e clica em download e instala√ß√£o? Bem, √© poss√≠vel fazer isso, mas h√° algo melhor chamado reposit√≥rios de pacotes. Reposit√≥rios s√£o simplesmente locais de armazenamento centralizados para pacotes. Existem montes de reposit√≥rios que guardam uma diversidade de pacotes e, melhor ainda, eles est√£o todos dispon√≠veis na internet.\nPara exemplo, imagine que eu quero instalar o software fict√≠cio linuxteclab no meu computador. linuxteclab gerencia seus pr√≥prios reposit√≥rios para pacotes. Ele hospeda esse reposit√≥rio no endere√ßo-fonte: http://download.linuxteclab.com.br/linux/deb/\nEm vez de ir √† sua p√°gina inicial para baixar o pacote diretamente, voc√™ pode instruir o seu computador a encontrar o software no endere√ßo do link acima.\nSua distribui√ß√£o j√° vem com fontes pr√©-aulilizadas para obter pacotes e isso √© como ela instala todos os pacotes b√°sicos que voc√™ v√™ em seu sistema. Em um sistema Debian, esse arquivo de fontes √© o /etc/apt/sources.list. O seu computador saber√° buscar l√° e verificar se h√° reposit√≥rios fontes adicionais.\nExemplo:\nVoc√™ pode adicionar fontes adicionais em seu arquivo /etc/apt/sources.list para obter pacotes personalizados. Por exemplo, voc√™ pode adicionar a seguinte linha para obter o reposit√≥rio do Ubuntu:\ndeb http://archive.ubuntu.com/ubuntu xenial main restricted\nIsso permitir√° que voc√™ obtenha pacotes do Ubuntu Xenial naquela fonte.",
    "crumbs": [
      "Home",
      "üìÇ Pacotes",
      "‚úÖ Reposit√≥rios"
    ]
  }
]